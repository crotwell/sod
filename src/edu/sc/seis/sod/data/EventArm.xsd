<?xml version="1.0"?>

<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    
    <xsd:annotation>
        <xsd:documentation xml:lang="en">
            Schema for the EventArm of SOD
        </xsd:documentation>
    </xsd:annotation>
    
    <!-- Include the external schemas necessary for this schema -->
    <xsd:include schemaLocation="./utilities.xsd"/>
    
    <!-- BEGIN Event Source -->
    
    <!-- event source abstract type -->
    <xsd:complexType name="eventSourceType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sourceType"/>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- EVENT FINDER TYPE -->
    <xsd:complexType name="eventFinderType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Retrieve events from an EventFinder.
                </summary>
                <description>
                    A Fissures/DHI EventDC service is located via the name
                    and dns tags. The EventFinder is aquired from the EventDC,
                    and a query is sent with the given arguments. The events
                    returned are then sent thrrough the EventArm for processing.
                </description>
                <example>
                    <eventFinder>
                        <name>IRIS_EventDC</name>
                        <dns>edu/iris/dmc</dns>
                        <boxArea>
                            <latitudeRange>
                                <min>-90</min>
                                <max>90</max>
                            </latitudeRange>
                            <longitudeRange>
                                <min>-180</min>
                                <max>180</max>
                            </longitudeRange>
                        </boxArea>
                        <originDepthRange>
                            <unitRange>
                                <unit>KILOMETER</unit>
                                <min>0</min>
                                <max>1000</max>
                            </unitRange>
                        </originDepthRange>
                        <eventTimeRange>
                            <timeRange>
                                <startTime>20020101T00:00:00.001Z</startTime>
                                <endTime>20020201T00:00:00.001Z</endTime>
                            </timeRange>
                        </eventTimeRange>
                        <magnitudeRange>
                            <magType>%</magType>
                            <min>6.0</min>
                            <max>10.0</max>
                        </magnitudeRange>
                        <catalog><value>FINGER</value></catalog>
                        <contributor>NEIC</contributor>
                    </eventFinder>
                    
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventSourceType">
                <xsd:sequence>
                    <xsd:element ref="area"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="originDepthRange"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="eventTimeRange"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="magnitudeRange"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="catalog" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- EVENT CHANNEL FINDER TYPE -->
    <xsd:complexType name="eventChannelFinderType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Listens for event notifications from an event channel.
                </summary>
                <description>
                    A Fissures/DHI EventDC service is located via the name
                    and dns tags. The EventChannelFinder is aquired from the 
                    EventDC, and sod registers as a listener for event 
                    notifications with the event channel with the given name.
                    As events are received, they are sent through the EventArm
                    for processing.
                </description>
                <example>
                    <eventChannelFinder>
                        <name>IRIS_EventDC</name>
                        <dns>edu/iris/dmc</dns>
                        <eventchannelname>TestEventChannel</eventchannelname>
                    </eventChannelFinder>
                </example>
            </xsd:documentation>
        </xsd:annotation>        <xsd:complexContent>
            <xsd:extension base="eventSourceType">
                <xsd:sequence>
                    <xsd:element name="eventchannelname" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    
    <!-- END Event Source -->    
    
    <!-- BEGIN EventAttr -->
    
    <!-- This is the base abstract Type -->
    <xsd:complexType name="eventAttrType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                Superclass for all subsetters that act on EventAttr objects. 
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="eventAttrANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between EventAttr subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all 
                    included EventAttr subsetters. The subsetters after the
                    first false outputed are not evaluated. 
                </description>
                <example>
                    <eventAttrAND>
                        <eventAttrName>Fred</eventAttrName>
                        <geographicRegion>47</geographicRegion>
                    </eventAttrAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="0" maxOccurs="unbounded">
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="eventAttrORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between EventAttr subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all 
                    included EventAttr subsetters. If the first subsetters returns
                    true then the second is not evaluated. 
                </description>
                <example>
                    <eventAttrOR>
                        <eventAttrName>Fred</eventAttrName>
                        <geographicRegion>47</geographicRegion>
                    </eventAttrOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="0"
                    maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="eventAttrXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between EventAttr subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all 
                    included EventAttr subsetters.
                </description>
                <example>
                    <eventAttrXOR>
                        <eventAttrName>Fred</eventAttrName>
                        <geographicRegion>47</geographicRegion>
                    </eventAttrXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="eventAttrNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an EventAttr subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the 
                    included EventAttr subsetter.
                </description>
                <example>
                    <eventAttrNOT>
                        <geographicRegion><value>47</value></geographicRegion>
                    </eventAttrNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>	
    
    <xsd:complexType name="eventAttrNameType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the event name.
                </summary>
                <description>
                    Evaluates to true if the name of the event matches the string.
                </description>
                <example>
                    <eventAttrName>
                        <value>Fred</value>
                    </eventAttrName>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="geographicRegionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the geographic Flinn-Engdahl region number.
                </summary>
                <description>
                    Evaluates to true if the numerical value of the geographic 
                    region of the event matches one of the values in the list.
                </description>
                <example>
                    <geographicRegion>
                        <value>12 47</value>
                    </geographicRegion>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element name="value" type="flinnengdahlNumbers"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="seismicRegionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the seismic Flinn-Engdahl region number.
                </summary>
                <description>
                    Evaluates to true if the numerical value of the seismic 
                    region of the event matches one of the values in the list.
                </description>
                <example>
                    <seismicRegion>
                        <value>12 47</value> 
                    </seismicRegion>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element name="value" type="flinnengdahlNumbers"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:simpleType name="flinnengdahlList">
        <xsd:list itemType="xsd:nonNegativeInteger">
        </xsd:list>
    </xsd:simpleType>
    
    <!-- This is derived from flinnengdahlList, the purpose is  to restrict in such a way that the following is not allowed
    in the instance document
    <seismicRegion><value></value></seismicRegion>
    -->
    <xsd:simpleType name="flinnengdahlNumbers">
        <xsd:restriction base="flinnengdahlList">
            <xsd:minLength value="1"/>
        </xsd:restriction>
    </xsd:simpleType>
    
    <!-- element representing the seismicRegion and the substitutionGroup is eventAttr which is an abstract
    element-->
    <xsd:element name="seismicRegion" type="seismicRegionType" substitutionGroup="eventAttr"/>
    
    <!-- END EventAttr -->
    
    <!-- BEGIN Origin -->    
    
    <xsd:complexType name="originType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Superclass for all subsetters that act on Origin objects.
                </summary>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="originTimeRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matchs events who's preferred origin's origin time occurs
                    within the given time range. 
                </summary>
                <description>
                    
                </description>
                <example>
                    <originTimeRange>
                        <timeRange>
                            <startTime>20010101T00:00:00Z</startTime>
                            <endTime>20011231T00:00:00Z</endTime>
                        </timeRange>
                    </originTimeRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="timeRange"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="magnitudeType">
        <xsd:complexContent>	
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="magType" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="min" type="xsd:float"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="max" type="xsd:float"  minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="originDepthRangeType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="unitRange" type="unitRangeType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    
    <!-- LOCATION TYPE TYPE -->
    <xsd:simpleType name="locationtypeType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="GEOGRAPHIC"/>
            <xsd:enumeration value="GEOCENTRIC"/>
        </xsd:restriction>
    </xsd:simpleType>
    
    <!-- LOCATION TYPE -->
    <xsd:complexType name="locationType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="latitude" type="xsd:float"/>
                    <xsd:element name="longitude" type="xsd:float"/>
                    <xsd:element name="elevation" type="lengthType"/>
                    <xsd:element name="depth" type="lengthType"/>
                    <xsd:element name="locationType" type="locationtypeType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- CATALOG TYPE -->
    <xsd:complexType name="catalogType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- CONTRIBUTOR TYPE -->
    <xsd:complexType name="contributorType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>	
    
    
    <!-- ORIGIN AND TYPE -->
    <xsd:complexType name="originANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between Origin subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all 
                    included Origin subsetters. The subsetters after the
                    first false outputed are not evaluated. 
                </description>
                <example>
                    <originAND>
                        <catalog><value>FINGER</value></catalog>
                        <contributor><value>NEIC</value></contributor>
                    </originAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    
    <xsd:complexType name="originORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between Origin subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all 
                    included Origin subsetters. The subsetters after the
                    first true outputed are not evaluated. 
                </description>
                <example>
                    <originOR>
                        <catalog><value>FINGER</value></catalog>
                        <contributor><value>NEIC</value></contributor>
                    </originOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- ORIGIN XOR TYPE -->
    <xsd:complexType name="originXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between Origin subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all 
                    included Origin subsetters.  
                </description>
                <example>
                    <originXOR>
                        <catalog><value>FINGER</value></catalog>
                        <contributor><value>NEIC</value></contributor>
                    </originXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- ORIGIN NOT TYPE -->
    <xsd:complexType name="originNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an Origin subsetter.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all 
                    included Origin subsetters.  
                </description>
                <example>
                    <originNOT>
                        <catalog><value>FINGER</value></catalog>
                    </originNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- END Origin -->
    
    <!-- BEGIN Event Process -->
    
    <!-- EVENT PROCESS TYPE -->
    <xsd:complexType name="externalEventProcessType">
        <xsd:complexContent>
            <xsd:extension base="externalProcessType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="printLineEventProcessType">
        <xsd:complexContent>
            <xsd:extension base="internalProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    
    <!-- ORIGIN ARRAY AND -->
    <xsd:complexType name="originArrayANDType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- ORIGIN ARRAY OR -->
    <xsd:complexType name="originArrayORType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- element representing the geographicalRegion and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="geographicalRegion" type="geographicRegionType" substitutionGroup="eventAttr"/>
    
    <!-- element representing the eventAttrAND and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrAND" type="eventAttrANDType" substitutionGroup="eventAttr"/>
    
    <!-- element representing the eventAttrOR and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrOR" type="eventAttrORType" substitutionGroup="eventAttr"/>
    
    <!-- element representing the eventAttrXOR and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrXOR" type="eventAttrXORType" substitutionGroup="eventAttr"/>
    
    <!-- element representing the eventAttrNOT and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrNOT" type="eventAttrNOTType" substitutionGroup="eventAttr"/>
    
    <!-- element  representing the eventAttrName and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrName" type="eventAttrNameType" substitutionGroup="eventAttr"/>
    
    <!-- This element eventAttr is the base Abstract element -->
    <xsd:element name="eventAttr" type="eventAttrType" abstract="true"/>
    
    
    <!-- This element origin is the base Abstract element -->
    <xsd:element name="origin" type="originType" abstract="true"/>
    
    <!-- element representing magnitude -->
    <xsd:element name="magnitudeRange" type="magnitudeType" substitutionGroup="origin"/>
    
    <!-- element representing depth Range-->
    <xsd:element name="originDepthRange" type="originDepthRangeType" substitutionGroup="origin"/>	
    
    <!-- EVENT AREA TYPE -->
    <xsd:complexType name="eventAreaType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="area"/>
                </xsd:sequence>	
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    
    <!-- element representing eventArea -->
    <xsd:element name="eventArea" type="eventAreaType" substitutionGroup="origin"/>
    
    <!-- elment representing CATALOG -->
    <xsd:element name="catalog" type="catalogType" substitutionGroup="origin"/>
    
    <!-- element representing CONTRIBUTOR -->
    <xsd:element name="contributor" type="contributorType" substitutionGroup="origin"/>
    
    <!-- element representing ORIGIN ARRAY AND -->
    <xsd:element name="originArrayAND" type="originArrayANDType" substitutionGroup="origin"/>
    
    <!-- element representing ORIGIN ARRAY OR -->
    <xsd:element name="originArrayOR" type="originArrayORType" substitutionGroup="origin"/>
    
    <!-- element representing originAND -->
    <xsd:element name="originAND" type="originANDType" substitutionGroup="origin"/>
    
    <!-- element representing originOR -->
    <xsd:element name="originOR" type="originORType" substitutionGroup="origin"/>
    
    <!-- element representing originXOR -->
    <xsd:element name="originXOR" type="originXORType" substitutionGroup="origin"/>
    
    <!-- element representing originNOT -->
    <xsd:element name="originNOT" type="originNOTType" substitutionGroup="origin"/>
    
    <!-- element representing timeRange -->
    <xsd:element name="originTimeRange" type="originTimeRangeType" substitutionGroup="origin"/>
    
    <!-- The element eventSource is the base abstract element -->
    <xsd:element name="eventSource" type="eventSourceType" abstract="true"/>
    
    <!-- element representing eventFinder -->
    <xsd:element name="eventFinder" type="eventFinderType" substitutionGroup="eventSource"/>
    
    <!-- element representing eventChannelFinder -->
    <xsd:element name="eventChannelFinder" type="eventChannelFinderType" substitutionGroup="eventSource"/>
    
    <!-- element representing the process -->
    <xsd:element name="eventProcess" type="processType" abstract="true"/>
    <xsd:element name="printLineEventProcess" type="printLineEventProcessType" substitutionGroup="eventProcess"/>
    <xsd:element name="externalEventProcess" type="externalEventProcessType" substitutionGroup="eventProcess"/>
    
    <xsd:complexType name="eventArmType">	
        <xsd:complexContent>
            <xsd:extension base="armType">
                <xsd:sequence>
                    <xsd:element ref="eventSource"
                        minOccurs="1"
                    maxOccurs="unbounded"/>
                    <xsd:element ref="eventAttr" minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="origin" minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="eventProcess" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <!-- element representing EVENTARM -->    
    <xsd:element name="eventArm" type="eventArmType"/>
    
</xsd:schema>
