<?xml version="1.0"?>

<xsd:schema targetNamespace="http://www.seis.sc.edu/xschema/sod/1.0"
xmlns="http://www.seis.sc.edu/xschema/sod/1.0"
xmlns:target="http://www.seis.sc.edu/xschema/sod/1.0"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema">

<!--
 targetNamespace="http://www.seis.sc.edu/xschema/sod/1.0"
 -->

 <xsd:annotation>
  <xsd:documentation xml:lang="en">
            Schema for the SOD
  </xsd:documentation>
 </xsd:annotation>

    <xsd:complexType name="sodType">
        <xsd:sequence>

            <xsd:element name="properties" minOccurs="0" maxOccurs="1">
                <xsd:complexType>
        <xsd:sequence>
            <xsd:element name="property" type="target:propertyType" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
    </xsd:complexType>
            </xsd:element>
            <xsd:element name="eventArm" type="target:eventArmType" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="networkArm" type="target:networkArmType" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="waveFormArm" type="target:waveFormArmType" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:element name="sod" type="target:sodType"/>


<!-- utilities -->


    <!-- MAIN ABSTRACT BASE TYPE FOR SOD -->
    <xsd:complexType name="sodItemType" abstract="true">
        <xsd:sequence>
            <xsd:element name="description" type="xsd:string" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- ABSTRACT TYPE FOR SOURCE -->
    <xsd:complexType name="sourceType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sodItemType">
                <xsd:sequence>
                    <xsd:element name="name" type="xsd:string"/>
                    <xsd:element name="dns" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ABSTRACT TYPE FOR ARMS -->
    <xsd:complexType name="armType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sodItemType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE FOR SUBSETTER -->
    <xsd:complexType name="subsetterType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sodItemType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- mainly used in the NetworkARm EFFECTIVE TIME OVERLAP TYPE -->
    <xsd:complexType name="effectiveTimeOverlapType">
        <xsd:sequence>
            <xsd:element name="min" type="xsd:dateTime" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="max" type="xsd:dateTime" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>


    <!-- PARAMS TYPE -->
    <xsd:complexType name="paramsType">
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string"/>
            <xsd:element name="value" type="xsd:string"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- PROPERTY TYPE -->
    <xsd:complexType name="propertyType">
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="value" type="xsd:string" minOccurs="1" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>



    <!-- PROCESS TYPE -->
    <xsd:complexType name="processType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sodItemType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EXTERNAL PROCESS TYPE -->
    <xsd:complexType name="externalProcessType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="processType">
                <xsd:sequence>
                    <xsd:element name="classname" type="xsd:string"/>
                    <xsd:any processContents="lax"  minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- INTERNAL PROCESS TYPE -->
    <xsd:complexType name="internalProcessType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="processType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- UNIT  TYPE -->
    <xsd:simpleType name="unitType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="KILOMETER"/>
            <xsd:enumeration value="METER"/>
            <xsd:enumeration value="CENTIMETER"/>
            <xsd:enumeration value="NANOMETER"/>
            <xsd:enumeration value="MICROMETER"/>
            <xsd:enumeration value="MICRON"/>
            <xsd:enumeration value="MILLIMETER"/>
            <xsd:enumeration value="PICOMETER"/>
            <xsd:enumeration value="INCH"/>
            <xsd:enumeration value="FOOT"/>
            <xsd:enumeration value="MILE"/>
            <xsd:enumeration value="HERTZ"/>
            <xsd:enumeration value="NANOSECOND"/>
            <xsd:enumeration value="MICROSECOND"/>
            <xsd:enumeration value="MILLISECOND"/>
            <xsd:enumeration value="SECOND"/>
            <xsd:enumeration value="MINUTE"/>
            <xsd:enumeration value="HOUR"/>
            <xsd:enumeration value="DAY"/>
            <xsd:enumeration value="YEAR"/>
            <xsd:enumeration value="AMPERE"/>
            <xsd:enumeration value="COULOMB"/>
            <xsd:enumeration value="VOLT"/>
            <xsd:enumeration value="DEGREE"/>
            <xsd:enumeration value="RADIAN"/>
            <xsd:enumeration value="COUNT"/>
            <xsd:enumeration value="RADIAN_PER_SECOND"/>
            <xsd:enumeration value="SQUARE_METER"/>
            <xsd:enumeration value="SQUARE_CENTIMETER"/>
            <xsd:enumeration value="CUBIC_METER"/>
            <xsd:enumeration value="CUBIC_CENTIMETER"/>
            <xsd:enumeration value="LITER"/>
            <xsd:enumeration value="GRAM"/>
            <xsd:enumeration value="KILOGRAM"/>
            <xsd:enumeration value="DENSITY"/>
            <xsd:enumeration value="GRAM_PER_CUBIC_CENTIMETER"/>
            <xsd:enumeration value="KILOGRAM_PER_CUBIC_METER"/>
            <xsd:enumeration value="VELOCITY"/>
            <xsd:enumeration value="METER_PER_SECOND"/>
            <xsd:enumeration value="CENTIMETER_PER_SECOND"/>
            <xsd:enumeration value="KILOMETER_PER_SECOND"/>
            <xsd:enumeration value="MILLIMETER_PER_SECOND"/>
            <xsd:enumeration value="MICROMETER_PER_SECOND"/>
            <xsd:enumeration value="MICRON_PER_SECOND"/>
            <xsd:enumeration value="NANOMETER_PER_SECOND"/>
            <xsd:enumeration value="ACCELERATION"/>
            <xsd:enumeration value="METER_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="CENTIMETER_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="KILOMETER_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="MILLIMETER_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="MICROMETER_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="MICRON_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="NANOMETER_PER_SECOND_PER_SECOND"/>
            <xsd:enumeration value="FORCE"/>
            <xsd:enumeration value="NEWTON"/>
            <xsd:enumeration value="JOULE"/>
            <xsd:enumeration value="DYNE"/>
            <xsd:enumeration value="ENERGY"/>

        </xsd:restriction>
    </xsd:simpleType>

    <!-- QUANTITY TYPE -->
    <xsd:complexType name="quantityType">
        <xsd:sequence>
            <xsd:element name="unit" type="unitType"/>
            <xsd:element name="value" type="xsd:integer"/>
        </xsd:sequence>
    </xsd:complexType>



    <!-- UNIT RANGE TYPE -->
    <xsd:complexType name="unitRangeType">
        <xsd:sequence>
            <xsd:element name="unit" type="unitType"/>
            <xsd:element name="min" type="xsd:double"  minOccurs="0" maxOccurs="1"/>
            <xsd:element name="max" type="xsd:double"  minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- TIME INTERVAL TYPE -->
    <xsd:complexType name="timeIntervalType">
        <xsd:complexContent>
            <xsd:extension base="quantityType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- REFRESH INTERVAL TYPE -->
    <xsd:complexType name="refreshIntervalType">
        <xsd:complexContent>
            <xsd:extension base="timeIntervalType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- LENGTH TYPE -->
    <xsd:complexType name="lengthType">
        <xsd:complexContent>
            <xsd:extension base="quantityType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AREA TYPE is abstract -->
    <xsd:complexType name="areaType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sodItemType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- BOX AREA TYPE -->
    <xsd:complexType name="boxAreaType">
        <xsd:complexContent>
            <xsd:extension base="areaType">
                <xsd:sequence>
                    <xsd:element ref="latitudeRange"/>
                    <xsd:element ref="longitudeRange"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- POINT AREA TYPE -->
    <xsd:complexType name="pointAreaType">
        <xsd:complexContent>
            <xsd:extension base="areaType">
                <xsd:sequence>
                    <xsd:element name="latitude" type="xsd:float"/>
                    <xsd:element name="longitude" type="xsd:float"/>
                    <xsd:element ref="distanceRange"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>



    <!-- LATITUDE TYPE -->
    <xsd:complexType name="latitudeLongitudeRangeType">
        <xsd:sequence>
            <xsd:element name="min" type="xsd:float"  minOccurs="0" maxOccurs="1"/>
            <xsd:element name="max" type="xsd:float"  minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>


    <!-- GLOBAL AREA TYPE -->
    <xsd:complexType name="globalAreaType">
        <xsd:complexContent>
            <xsd:extension base="areaType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>



    <!-- TIME  RANGE TYPE -->
    <xsd:complexType name="timeRangeType">
        <xsd:sequence>
            <xsd:element name="startTime" type="xsd:dateTime"  minOccurs="0" maxOccurs="1"/>
            <xsd:element name="endTime" type="xsd:dateTime"  minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- abstract element areaType -->
    <xsd:element name="area" type="areaType" abstract="true"/>

    <!-- element representing boxArea -->
    <xsd:element name="boxArea" type="boxAreaType" substitutionGroup="area"/>

    <!-- element representing globalArea -->
    <xsd:element name="globalArea" type="globalAreaType" substitutionGroup="area"/>

    <!-- element representing pointArea -->
    <xsd:element name="pointArea" type="pointAreaType" substitutionGroup="area"/>

    <!-- element representing latitude -->
    <xsd:element name="latitudeRange" type="latitudeLongitudeRangeType"/>

    <!-- element representing longitude -->
    <xsd:element name="longitudeRange" type="latitudeLongitudeRangeType"/>

    <!-- timeRangeType element -->
    <xsd:element name="timeRange" type="timeRangeType"/>

    <!-- REFRESH INTERVAL element -->
    <xsd:element name="refreshInterval" type="refreshIntervalType"/>

    <xsd:simpleType name="channelCodeUtilType">
        <xsd:restriction base="xsd:string">
            <xsd:pattern value="[A-Z]{1}"/>
        </xsd:restriction>
    </xsd:simpleType>




<!--
    <xsd:annotation>
        <xsd:documentation xml:lang="en">
            Schema for the EventArm of SOD
        </xsd:documentation>
    </xsd:annotation>
-->


    <!-- BEGIN Event Source -->

    <!-- event source abstract type -->
    <xsd:complexType name="eventSourceType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sourceType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT FINDER TYPE -->
    <xsd:complexType name="eventFinderType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Retrieve events from an EventFinder.
                </summary>
                <description>
                    A Fissures/DHI EventDC service is located via the name
                    and dns tags. The EventFinder is aquired from the EventDC,
                    and a query is sent with the given arguments. The events
                    returned are then sent thrrough the EventArm for processing.
                </description>
                <example>
                    <eventFinder>
                        <name>IRIS_EventDC</name>
                        <dns>edu/iris/dmc</dns>
                        <boxArea>
                            <latitudeRange>
                                <min>-90</min>
                                <max>90</max>
                            </latitudeRange>
                            <longitudeRange>
                                <min>-180</min>
                                <max>180</max>
                            </longitudeRange>
                        </boxArea>
                        <originDepthRange>
                            <unitRange>
                                <unit>KILOMETER</unit>
                                <min>0</min>
                                <max>1000</max>
                            </unitRange>
                        </originDepthRange>
                        <eventTimeRange>
                            <timeRange>
                                <startTime>20020101T00:00:00.001Z</startTime>
                                <endTime>20020201T00:00:00.001Z</endTime>
                            </timeRange>
                        </eventTimeRange>
                        <magnitudeRange>
                            <magType>%</magType>
                            <min>6.0</min>
                            <max>10.0</max>
                        </magnitudeRange>
                        <catalog><value>FINGER</value></catalog>
                        <contributor>NEIC</contributor>
                    </eventFinder>

                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventSourceType">
                <xsd:sequence>
                    <xsd:element ref="area"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="originDepthRange"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="originTimeRange"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="magnitudeRange"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="catalog" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element ref="contributor" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT CHANNEL FINDER TYPE -->
    <xsd:complexType name="eventChannelFinderType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Listens for event notifications from an event channel.
                </summary>
                <description>
                    A Fissures/DHI EventDC service is located via the name
                    and dns tags. The EventChannelFinder is aquired from the
                    EventDC, and sod registers as a listener for event
                    notifications with the event channel with the given name.
                    As events are received, they are sent through the EventArm
                    for processing.
                </description>
                <example>
                    <eventChannelFinder>
                        <name>IRIS_EventDC</name>
                        <dns>edu/iris/dmc</dns>
                        <eventchannelname>TestEventChannel</eventchannelname>
                    </eventChannelFinder>
                </example>
            </xsd:documentation>
        </xsd:annotation>        <xsd:complexContent>
            <xsd:extension base="eventSourceType">
                <xsd:sequence>
                    <xsd:element name="eventchannelname" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- END Event Source -->

    <!-- BEGIN EventAttr -->

    <!-- This is the base abstract Type -->
    <xsd:complexType name="eventAttrType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all EventAttr subsetters.
            </summary>
            <description>
                This is a place holder for EventAttr subsetters. See the
                list of known subclasses for subsetters that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="eventAttrANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between EventAttr subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included EventAttr subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <eventAttrAND>
                        <eventAttrName>Fred</eventAttrName>
                        <geographicRegion>47</geographicRegion>
                    </eventAttrAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="0" maxOccurs="unbounded">
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="eventAttrORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between EventAttr subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included EventAttr subsetters. If the first subsetters returns
                    true then the second is not evaluated.
                </description>
                <example>
                    <eventAttrOR>
                        <eventAttrName>Fred</eventAttrName>
                        <geographicRegion>47</geographicRegion>
                    </eventAttrOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>

        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="0"
                    maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="eventAttrXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between EventAttr subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included EventAttr subsetters.
                </description>
                <example>
                    <eventAttrXOR>
                        <eventAttrName>Fred</eventAttrName>
                        <geographicRegion>47</geographicRegion>
                    </eventAttrXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>

        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="eventAttrNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an EventAttr subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included EventAttr subsetter.
                </description>
                <example>
                    <eventAttrNOT>
                        <geographicRegion><value>47</value></geographicRegion>
                    </eventAttrNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element ref="eventAttr" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="eventAttrNameType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the event name.
                </summary>
                <description>
                    Evaluates to true if the name of the event matches the string.
                </description>
                <example>
                    <eventAttrName>
                        <value>Fred</value>
                    </eventAttrName>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="geographicRegionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the geographic Flinn-Engdahl region number.
                </summary>
                <description>
                    Evaluates to true if the numerical value of the geographic
                    region of the event matches one of the values in the list.
                </description>
                <example>
                    <geographicRegion>
                        <value>12 47</value>
                    </geographicRegion>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element name="value" type="flinnengdahlNumbers"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="seismicRegionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the seismic Flinn-Engdahl region number.
                </summary>
                <description>
                    Evaluates to true if the numerical value of the seismic
                    region of the event matches one of the values in the list.
                </description>
                <example>
                    <seismicRegion>
                        <value>12 47</value>
                    </seismicRegion>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventAttrType">
                <xsd:sequence>
                    <xsd:element name="value" type="flinnengdahlNumbers"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="flinnengdahlList">
        <xsd:list itemType="xsd:nonNegativeInteger">
        </xsd:list>
    </xsd:simpleType>

    <!-- This is derived from flinnengdahlList, the purpose is  to restrict in such a way that the following is not allowed
    in the instance document
    <seismicRegion><value></value></seismicRegion>
    -->
    <xsd:simpleType name="flinnengdahlNumbers">
        <xsd:restriction base="flinnengdahlList">
            <xsd:minLength value="1"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- element representing the seismicRegion and the substitutionGroup is eventAttr which is an abstract
    element-->
    <xsd:element name="seismicRegion" type="seismicRegionType" substitutionGroup="eventAttr"/>

    <!-- END EventAttr -->

    <!-- BEGIN Origin -->

    <xsd:complexType name="originType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all Origin subsetters.
            </summary>
            <description>
                This is a place holder for Origin subsetters. See the
                list of known subclasses for subsetters that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="originTimeRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matchs events who's preferred origin's origin time occurs
                    within the given time range.
                </summary>
                <description>

                </description>
                <example>
                    <originTimeRange>
                        <timeRange>
                            <startTime>20010101T00:00:00Z</startTime>
                            <endTime>20011231T00:00:00Z</endTime>
                        </timeRange>
                    </originTimeRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="timeRange"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="magnitudeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Accepts a range of magnitudes.
                </summary>
                <description>
                   If the origin has a magnitude of the given types, and it is
                   greater than or equals to the min and less than or equal to
                   the max, then it is accepted. If the type is missing, than
                   any type is accepted.
                </description>
                <example>
                      <magnitudeRange>
                          <magType>mb</magType>
                          <magType>M</magType>
                          <min>5.5</min>
                      </magnitudeRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="magType" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="min" type="xsd:float"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="max" type="xsd:float"  minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="originDepthRangeType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="unitRange" type="unitRangeType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- LOCATION TYPE TYPE -->
    <xsd:simpleType name="locationtypeType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="GEOGRAPHIC"/>
            <xsd:enumeration value="GEOCENTRIC"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- LOCATION TYPE -->
    <xsd:complexType name="locationType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="latitude" type="xsd:float"/>
                    <xsd:element name="longitude" type="xsd:float"/>
                    <xsd:element name="elevation" type="lengthType"/>
                    <xsd:element name="depth" type="lengthType"/>
                    <xsd:element name="locationType" type="locationtypeType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- CATALOG TYPE -->
    <xsd:complexType name="catalogType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- CONTRIBUTOR TYPE -->
    <xsd:complexType name="contributorType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT AREA TYPE -->
    <xsd:complexType name="eventAreaType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="area"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ORIGIN AND TYPE -->
    <xsd:complexType name="originANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between Origin subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included Origin subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <originAND>
                        <catalog><value>FINGER</value></catalog>
                        <contributor><value>NEIC</value></contributor>
                    </originAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="originORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between Origin subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included Origin subsetters. The subsetters after the
                    first true outputed are not evaluated.
                </description>
                <example>
                    <originOR>
                        <catalog><value>FINGER</value></catalog>
                        <contributor><value>NEIC</value></contributor>
                    </originOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ORIGIN XOR TYPE -->
    <xsd:complexType name="originXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between Origin subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included Origin subsetters.
                </description>
                <example>
                    <originXOR>
                        <catalog><value>FINGER</value></catalog>
                        <contributor><value>NEIC</value></contributor>
                    </originXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ORIGIN NOT TYPE -->
    <xsd:complexType name="originNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an Origin subsetter.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included Origin subsetters.
                </description>
                <example>
                    <originNOT>
                        <catalog><value>FINGER</value></catalog>
                    </originNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ORIGIN ARRAY AND -->
    <xsd:complexType name="originArrayANDType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ORIGIN ARRAY OR -->
    <xsd:complexType name="originArrayORType">
        <xsd:complexContent>
            <xsd:extension base="originType">
                <xsd:sequence>
                    <xsd:element ref="origin"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- END Origin -->

    <!-- BEGIN Event Process -->

    <!-- EVENT PROCESS TYPE -->
    <xsd:complexType name="eventProcessType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="subsetterType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="externalEventProcessType">
        <xsd:complexContent>
            <xsd:extension base="eventProcessType">
                <xsd:sequence>
                    <xsd:element name="classname" type="xsd:string"/>
                    <xsd:any processContents="lax"  minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="printLineEventProcessType">
        <xsd:complexContent>
            <xsd:extension base="eventProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- element representing the geographicalRegion and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="geographicalRegion" type="geographicRegionType" substitutionGroup="eventAttr"/>

    <!-- element representing the eventAttrAND and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrAND" type="eventAttrANDType" substitutionGroup="eventAttr"/>

    <!-- element representing the eventAttrOR and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrOR" type="eventAttrORType" substitutionGroup="eventAttr"/>

    <!-- element representing the eventAttrXOR and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrXOR" type="eventAttrXORType" substitutionGroup="eventAttr"/>

    <!-- element representing the eventAttrNOT and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrNOT" type="eventAttrNOTType" substitutionGroup="eventAttr"/>

    <!-- element  representing the eventAttrName and the substitutionGroup is eventAttr which is an abstract element -->
    <xsd:element name="eventAttrName" type="eventAttrNameType" substitutionGroup="eventAttr"/>

    <!-- This element eventAttr is the base Abstract element -->
    <xsd:element name="eventAttr" type="eventAttrType" abstract="true"/>


    <!-- This element origin is the base Abstract element -->
    <xsd:element name="origin" type="originType" abstract="true"/>

    <!-- element representing magnitude -->
    <xsd:element name="magnitudeRange" type="magnitudeType" substitutionGroup="origin"/>

    <!-- element representing depth Range-->
    <xsd:element name="originDepthRange" type="originDepthRangeType" substitutionGroup="origin"/>

    <!-- element representing eventArea -->
    <xsd:element name="eventArea" type="eventAreaType" substitutionGroup="origin"/>

    <!-- elment representing CATALOG -->
    <xsd:element name="catalog" type="catalogType" substitutionGroup="origin"/>

    <!-- element representing CONTRIBUTOR -->
    <xsd:element name="contributor" type="contributorType" substitutionGroup="origin"/>

    <!-- element representing ORIGIN ARRAY AND -->
    <xsd:element name="originArrayAND" type="originArrayANDType" substitutionGroup="origin"/>

    <!-- element representing ORIGIN ARRAY OR -->
    <xsd:element name="originArrayOR" type="originArrayORType" substitutionGroup="origin"/>

    <!-- element representing originAND -->
    <xsd:element name="originAND" type="originANDType" substitutionGroup="origin"/>

    <!-- element representing originOR -->
    <xsd:element name="originOR" type="originORType" substitutionGroup="origin"/>

    <!-- element representing originXOR -->
    <xsd:element name="originXOR" type="originXORType" substitutionGroup="origin"/>

    <!-- element representing originNOT -->
    <xsd:element name="originNOT" type="originNOTType" substitutionGroup="origin"/>

    <!-- element representing timeRange -->
    <xsd:element name="originTimeRange" type="originTimeRangeType" substitutionGroup="origin"/>

    <!-- The element eventSource is the base abstract element -->
    <xsd:element name="eventSource" type="eventSourceType" abstract="true"/>

    <!-- element representing eventFinder -->
    <xsd:element name="eventFinder" type="eventFinderType" substitutionGroup="eventSource"/>

    <!-- element representing eventChannelFinder -->
    <xsd:element name="eventChannelFinder" type="eventChannelFinderType" substitutionGroup="eventSource"/>

    <!-- element representing the process -->
    <xsd:element name="eventProcess" type="eventProcessType" abstract="true"/>
    <xsd:element name="printLineEventProcess" type="printLineEventProcessType" substitutionGroup="eventProcess"/>
    <xsd:element name="externalEventProcess" type="externalEventProcessType" substitutionGroup="eventProcess"/>

    <xsd:complexType name="eventArmType">
        <xsd:complexContent>
            <xsd:extension base="armType">
                <xsd:sequence>
                    <xsd:element ref="eventSource"
                        minOccurs="1"
                    maxOccurs="unbounded"/>
                    <xsd:element ref="eventAttr" minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="origin" minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="eventProcess" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- element representing EVENTARM -->
    <xsd:element name="eventArm" type="eventArmType"/>

<!--
    <xsd:annotation>
        <xsd:documentation xml:lang="en">
            Schema for the NetworkArm of SOD
        </xsd:documentation>
    </xsd:annotation>
-->


    <!-- ABSTRACT TYPE DECLARATIONS -->

    <!--  abstractType networkSource -->
    <xsd:complexType name="networkSource" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="sourceType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!--abstractType networkAttr -->
    <xsd:complexType name="networkType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Abstract superclass of all NetworkAttr subsetters.
                </summary>
                <description>
                    This is a place holder for NetworkAttr subsetters. See the
                    list of known subclasses for subsetters that can be used.
                </description>
                <example>

                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- abstractType station -->
    <xsd:complexType name="stationType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Abstract superclass of all Station subsetters.
                </summary>
                <description>
                    This is a place holder for Station subsetters. See the
                    list of known subclasses for subsetters that can be used.
                </description>
                <example>

                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!--abstracType site -->
    <xsd:complexType name="siteType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Abstract superclass of all SiteId subsetters.
                </summary>
                <description>
                    This is a place holder for Site subsetters. See the
                    list of known subclasses for subsetters that can be used.
                </description>
                <example>

                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- abstractType channel -->
    <xsd:complexType name="channelType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Abstract superclass of all Channel subsetters.
                </summary>
                <description>
                    This is a place holder for Channel subsetters. See the
                    list of known subclasses for subsetters that can be used.
                </description>
                <example>

                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>



    <xsd:complexType name="networkFinderType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Finds networks.
                </summary>
                <description>
                    A Fissures/DHI NetworkDC service is located via the name
                    and dns tags. The NetworkFinder is aquired from the NetworkDC,
                    and a query is sent with the given arguments. The networks
                    returned are then sent thrrough the NetworkArm for processing.
                    An optional refresh interval can be given if sod should
                    periodically check for new channels.
                </description>
                <example>
                    <networkFinder>
                        <description>Connect to the IRIS networkDC</description>
                        <name>IRIS_NetworkDC</name>
                        <dns>edu/iris/dmc</dns>
                        <refreshInterval>
                            <unit>MINUTE</unit>
                            <value>3000</value>
                        </refreshInterval>
                    </networkFinder>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkSource">
                <xsd:sequence>
                    <xsd:element ref="refreshInterval" minOccurs = "0" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- NETWORK CODE TYPE -->
    <xsd:complexType name="networkCodeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches a given network code.
                </summary>
                <description>
                    A network is accepted if its network code matches the given
                    code exactly.
                </description>
                <example>
                    <networkCode><value>IC</value></networkCode>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- NETWORK EFFECTIVE TIME OVERLAP TYPE -->
    <xsd:complexType name="networkEffectiveTimeOverlapType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches if the network overlaps the given time range.
                </summary>
                <description>
                    Matches if the network overlaps the given time range.
                </description>
                <example>
                    <networkEffectiveTimeOverlap>
                        <description>
                            Make sure the network was up during the time range we
                            are interested in.
                        </description>
                        <effectiveTimeOverlap>
                            <min>20020701T00:00:00.001Z</min>
                            <max>20021030T00:00:00.001Z</max>
                        </effectiveTimeOverlap>
                    </networkEffectiveTimeOverlap>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element name="effectiveTimeOverlap" type="effectiveTimeOverlapType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="networkNameType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the name of a network.
                </summary>
                <description>
                    Matches the name of a network.
                </description>
                <example>
                    <networkName>
                        <value>Global Seismograph Network (GSN - IRIS/USGS)</value>
                    </networkName>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="networkOwnerType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the owner of a network.
                </summary>
                <description>
                    Matches the owner of a network. This is a simple string
                    comparision, and so care must be taken for it to be useful.
                </description>
                <example>
                    <networkOwner>
                        <value>Scripps Institution of Oceanography</value>
                    </networkOwner>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="networkANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between network subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <networkAND>
                        <networkOwner>
                            <value>Scripps Institution of Oceanography</value>
                        </networkOwner>
                        <networkEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </networkEffectiveTimeOverlap>
                    </networkAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element ref="network" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="networkORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between network subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. If the first subsetters returns
                    true then the second is not evaluated.
                </description>
                <example>
                    <networkOR>
                        <networkOwner>
                            <value>Scripps Institution of Oceanography</value>
                        </networkOwner>
                        <networkEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </networkEffectiveTimeOverlap>
                    </networkOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element ref="network" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="networkXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between network subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included subsetters.
                </description>
                <example>
                    <networkXOR>
                        <networkOwner>
                            <value>Scripps Institution of Oceanography</value>
                        </networkOwner>
                        <networkEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </networkEffectiveTimeOverlap>
                    </networkXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element ref="network" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="networkNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an network subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included subsetter.
                </description>
                <example>
                    <networkNOT>
                        <networkOwner>
                            <value>Scripps Institution of Oceanography</value>
                        </networkOwner>
                    </networkNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="networkType">
                <xsd:sequence>
                    <xsd:element ref="network" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

<!-- station subsetters -->
    <xsd:complexType name="stationCodeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches a station code.
                </summary>
                <description>
                    Matches a station code. This is a simple string match.
                </description>
                <example>
                    <stationCode>ANMO</stationCode>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- STATION NAME TYPE -->
    <xsd:complexType name="stationNameType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the name of a station.
                </summary>
                <description>
                    Matches the name of a station. This is a simple string
                    comparison, and so care must be taken for this to be useful.
                </description>
                <example>
                    <stationName>
                        <value>South Karori, New Zealand</value>
                    </stationName>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- STATION OPERATOR TYPE -->
    <xsd:complexType name="stationOperatorType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the operator of a station.
                </summary>
                <description>
                    Matches the operator of a station. This is a simple string
                    comparison, and so care must be taken for this to be useful.
                </description>
                <example>
                    <stationOperator>
                        <value>Joe Seismologist</value>
                    </stationOperator>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- STATION DEPTH RANGE TYPE -->
    <xsd:complexType name="stationDepthRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches stations at a range of depths below the surface.
                </summary>
                <description>
                    Matches stations at a range of depths below the surface.
                </description>
                <example>
                    <stationDepthRange>
                        <unitRange>
                            <unit>METER</unit>
                            <min>100</min>
                            <max>200</max>
                        </unitRange>
                    </stationDepthRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element name="unitRange" type="unitRangeType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--STATION EFFECTIVE TIME OVERLAP TYPE-->
    <xsd:complexType name="stationEffectiveTimeOverlapType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches if the station effective time overlaps the given time
                    range.
                </summary>
                <description>
                    Matches if the station effective time overlaps the given time
                    range. This is generally used to avoid processing stations
                    that did not yet exist, or were deactivated before a time
                    range of interest.
                </description>
                <example>
                    <stationEffectiveTimeOverlap>
                        <effectiveTimeOverlap>
                            <min>20020701T00:00:00.001Z</min>
                            <max>20021030T00:00:00.001Z</max>
                        </effectiveTimeOverlap>
                    </stationEffectiveTimeOverlap>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element name="effectiveTimeOverlap" type="effectiveTimeOverlapType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="stationAreaType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches stations that are within a given area.
                </summary>
                <description>
                    Matches stations that are within a given area. See the
                    documentation for Area to see the available area types.
                </description>
                <example>
                    <stationArea>
                        <boxArea>
                            <latitudeRange>
                                <min>25</min>
                                <max>35</max>
                            </latitudeRange>
                            <longitudeRange>
                                <min>-80</min>
                                <max>-70</max>
                            </longitudeRange>
                        </boxArea>
                    </stationArea>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element ref="area"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="stationANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between station subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <stationAND>
                        <stationEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element ref="station" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="stationORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between station subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. If the first subsetters returns
                    true then the second is not evaluated.
                </description>
                <example>
                    <stationOR>
                        <stationEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element ref="station" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="stationXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between station subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included subsetters.
                </description>
                <example>
                    <stationXOR>
                        <stationEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element ref="station" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="stationNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of a station subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included EventAttr subsetter.
                </description>
                <example>
                    <stationNOT>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="stationType">
                <xsd:sequence>
                    <xsd:element ref="station" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- TYPE DECLARATIONS FOR THE SUBSETTER SITE -->

    <xsd:complexType name="siteCodeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches a site code.
                </summary>
                <description>
                    Matches a site code. This is a simple string match.
                </description>
                <example>
                    <siteCode><value>00</value></siteCode>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element name="value" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>



    <xsd:complexType name="siteDepthRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches sites at a range of depths below the surface.
                </summary>
                <description>
                    Matches sites at a range of depths below the surface. This
                    might be used to separate surface sites from borehole sites.
                </description>
                <example>
                    <siteDepthRange>
                        <unitRange>
                            <unit>METER</unit>
                            <min>100</min>
                            <max>200</max>
                        </unitRange>
                    </siteDepthRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element name="unitRange" type="unitRangeType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="siteEffectiveTimeOverlapType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches if the site effective time overlaps the given time
                    range.
                </summary>
                <description>
                    Matches if the site effective time overlaps the given time
                    range. This is generally used to avoid processing sites
                    that did not yet exist, or were deactivated before a time
                    range of interest.
                </description>
                <example>
                    <siteEffectiveTimeOverlap>
                        <effectiveTimeOverlap>
                            <min>20020701T00:00:00.001Z</min>
                            <max>20021030T00:00:00.001Z</max>
                        </effectiveTimeOverlap>
                    </siteEffectiveTimeOverlap>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element name="effectiveTimeOverlap" type="effectiveTimeOverlapType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="siteAreaType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches sites that are within a given area.
                </summary>
                <description>
                    Matches sites that are within a given area. See the
                    documentation for Area to see the available area types.
                </description>
                <example>
                    <siteArea>
                        <boxArea>
                            <latitudeRange>
                                <min>25.123</min>
                                <max>25.124</max>
                            </latitudeRange>
                            <longitudeRange>
                                <min>-80.124</min>
                                <max>-80.123</max>
                            </longitudeRange>
                        </boxArea>
                    </siteArea>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element ref="area"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="siteANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between site subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <siteAND>
                        <siteDepthRange>
                            <unitRange>
                                <unit>METER</unit>
                                <min>100</min>
                                <max>200</max>
                            </unitRange>
                        </siteDepthRange>
                        <siteEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </siteEffectiveTimeOverlap>
                    </siteAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element ref="site" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="siteORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between site subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. If the first subsetters returns
                    true then the second is not evaluated.
                </description>
                <example>
                    <siteOR>
                        <siteDepthRange>
                            <unitRange>
                                <unit>METER</unit>
                                <min>100</min>
                                <max>200</max>
                            </unitRange>
                        </siteDepthRange>
                        <siteEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </siteEffectiveTimeOverlap>
                    </siteOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element ref="site" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="siteXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between site subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of the 2
                    included subsetters.
                </description>
                <example>
                    <siteXOR>
                        <siteDepthRange>
                            <unitRange>
                                <unit>METER</unit>
                                <min>100</min>
                                <max>200</max>
                            </unitRange>
                        </siteDepthRange>
                        <siteEffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </siteEffectiveTimeOverlap>
                    </siteXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element ref="site" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="siteNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an site subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included subsetter.
                </description>
                <example>
                    <siteNOT>
                        <siteDepthRange>
                            <unitRange>
                                <unit>METER</unit>
                                <min>100</min>
                                <max>200</max>
                            </unitRange>
                        </siteDepthRange>
                    </siteNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="siteType">
                <xsd:sequence>
                    <xsd:element ref="site" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- TYPE DECLARATIONS FOR THE SUBSETTER *****CHANNEL***** -->
    <xsd:complexType name="bandCodeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches a band code in a channel code.
                </summary>
                <description>
                    Matches a band code in a channel code, such as B for
                    broadband and L for long period. See the SEED manual for
                    the list of available code letters.
                </description>
                <example>
                    <bandCode><value>B</value></bandCode>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="value" type="channelCodeUtilType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="gainCodeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches a band code in a channel code.
                </summary>
                <description>
                    Matches a gain code in a channel code, such as H for
                    high gain and L for low gain. See the SEED manual for
                    the list of available code letters.
                </description>
                <example>
                    <gainCode><value>H</value></gainCode>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="value" type="channelCodeUtilType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--BAND CODE TYPE-->
    <xsd:complexType name="orientationCodeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches a orientation code in a channel code.
                </summary>
                <description>
                    Matches a orientation code in a channel code, such as Z for
                    vertical and N for north. See the SEED manual for
                    the list of available code letters.
                </description>
                <example>
                    <orientationCode><value>Z</value></orientationCode>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="value" type="channelCodeUtilType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="channelANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between channel subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <channelAND>
                        <channeleffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </channeleffectiveTimeOverlap>
                        <sampling>
                            <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
                    </channelAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element ref="channel" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="channelORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between channel subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. If the first subsetters returns
                    true then the second is not evaluated.
                </description>
                <example>
                    <channelOR>
                        <channeleffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </channeleffectiveTimeOverlap>
                        <sampling>
                            <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
                    </channelOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element ref="channel" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="channelXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between channel subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included subsetters.
                </description>
                <example>
                    <channelXOR>
                        <channeleffectiveTimeOverlap>
                            <effectiveTimeOverlap>
                                <min>20020701T00:00:00.001Z</min>
                                <max>20021030T00:00:00.001Z</max>
                            </effectiveTimeOverlap>
                        </channeleffectiveTimeOverlap>
                        <sampling>
                            <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
                    </channelXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element ref="channel" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="channelNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an channel subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included subsetter.
                </description>
                <example>
                    <channelNOT>
                        <sampling>
                            <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
                    </channelNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element ref="channel" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="samplingType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches if the sampling rate of the channel is within the
                    range.
                </summary>
                <description>
                    Matches if the sampling rate of the channel is within the
                    range. Both the min and max are optional, although at least
                    one must be given to have any effect.
                </description>
                <example>
                    <sampling>
                        <min>1</min>
                        <max>40</max>
                        <interval>
                            <unit>SECOND</unit>
                            <value>1</value>
                        </interval>
                    </sampling>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="min" type="xsd:integer"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="max" type="xsd:integer"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="interval" type="timeIntervalType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="channelEffectiveTimeOverlapType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches if the channel effective time overlaps the given time
                    range.
                </summary>
                <description>
                    Matches if the channel effective time overlaps the given time
                    range. This is generally used to avoid processing channels
                    that did not yet exist, or were deactivated before a time
                    range of interest.
                </description>
                <example>
                    <channelEffectiveTimeOverlap>
                        <effectiveTimeOverlap>
                            <min>20020701T00:00:00.001Z</min>
                            <max>20021030T00:00:00.001Z</max>
                        </effectiveTimeOverlap>
                    </channelEffectiveTimeOverlap>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="effectiveTimeOverlap" type="effectiveTimeOverlapType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="orientationRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches an orientation of a channel.
                </summary>
                <description>
                    The match is true if the channel's orientation is with the
                    offset of the given azimuth and dip. The offset, as well as
                    the azimuth and dip are given in degrees.
                </description>
                <example>
                    <orientationRange>
                        <azimuth>45</azimuth>
                        <dip>0</dip>
                        <maxOffset>20</maxOffset>
                    </orientationRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element ref="azimuth"/>
                    <xsd:element ref="dip"/>
                    <xsd:element name="maxOffset" type="xsd:float"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="orientationAzimuthRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the azimuth of a channel.
                </summary>
                <description>
                    The match is true if azimuth of the channel's orientation is with the
                    the given azimuth range. The min and max are given in degrees.
                </description>
                <example>
                    <orientationAzimuthRange>
                        <min>-10</min>
                        <max>10</max>
                    </orientationAzimuthRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="min" type="xsd:float"/>
                    <xsd:element name="max" type="xsd:float"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="orientationDipRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Matches the dip of a channel.
                </summary>
                <description>
                    The match is true if the dip of the channel's orientation is with the
                    the given dip range. The min and max are given in degrees.
                </description>
                <example>
                    <orientationDipRange>
                        <min>-10</min>
                        <max>10</max>
                    </orientationDipRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="channelType">
                <xsd:sequence>
                    <xsd:element name="min" type="xsd:float"/>
                    <xsd:element name="max" type="xsd:float"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- TYPE DECLARATIONS FOR THE PROCESSES AT THE END OF THE NETWORKARM -->

    <xsd:complexType name="externalNetworkProcessType">
        <xsd:complexContent>
            <xsd:extension base="externalProcessType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="printLineChannelProcessorType">
        <xsd:complexContent>
            <xsd:extension base="internalProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- common Global Elements of Network Arm -->
    <xsd:element name="azimuth" type="xsd:float"/>
    <xsd:element name="dip" type="xsd:float"/>

    <!-- ELEMENT DECLARATIONS FOR NETWORK SOURCE TYPE -->
    <xsd:element name="networkSource" abstract="true"/>

    <xsd:element name="networkFinder" type="networkFinderType" substitutionGroup="networkSource"/>

    <!-- ELEMENT DECLARATIONS FOR NETWORK  TYPE -->
    <xsd:element name="network" type="networkType" abstract="true"/>
    <xsd:element name="networkCode" type="networkCodeType" substitutionGroup="network"/>
    <xsd:element name="networkName" type="networkNameType" substitutionGroup="network"/>
    <xsd:element name="networkOwner" type="networkOwnerType" substitutionGroup="network"/>
    <xsd:element name="networkEffectiveTimeOverlap" type="networkEffectiveTimeOverlapType" substitutionGroup="network"/>
    <xsd:element name="networkAND" type="networkANDType" substitutionGroup="network"/>
    <xsd:element name="networkOR" type="networkORType" substitutionGroup="network"/>
    <xsd:element name="networkXOR" type="networkXORType" substitutionGroup="network"/>
    <xsd:element name="networkNOT" type="networkNOTType" substitutionGroup="network"/>

    <!-- ELEMENT DECLARATIONS FOR STATION TYPE -->
    <xsd:element name="station" type="stationType" abstract="true"/>
    <xsd:element name="stationCode" type="stationCodeType" substitutionGroup="station"/>
    <xsd:element name="stationName" type="stationNameType" substitutionGroup="station"/>
    <xsd:element name="stationOperator" type="stationOperatorType" substitutionGroup="station"/>
    <xsd:element name="stationDepthRange" type="stationDepthRangeType" substitutionGroup="station"/>
    <xsd:element name="stationEffectiveTimeOverlap" type="stationEffectiveTimeOverlapType" substitutionGroup="station"/>
    <!-- element representing eventArea -->
    <xsd:element name="stationArea" type="stationAreaType" substitutionGroup="station"/>
    <xsd:element name="stationAND" type="stationANDType" substitutionGroup="station"/>
    <xsd:element name="stationOR" type="stationORType" substitutionGroup="station"/>
    <xsd:element name="stationXOR" type="stationXORType" substitutionGroup="station"/>
    <xsd:element name="stationNOT" type="stationNOTType" substitutionGroup="station"/>

    <!-- ELEMENT DECLARATIONS FOR SITE TYPE -->
    <xsd:element name="site" type="siteType" abstract="true"/>
    <xsd:element name="siteCode" type="siteCodeType" substitutionGroup="site"/>
    <xsd:element name="siteDepthRange" type="siteDepthRangeType" substitutionGroup="site"/>
    <xsd:element name="siteEffectiveTimeOverlap" type="siteEffectiveTimeOverlapType" substitutionGroup="site"/>
    <!-- element representing siteArea -->
    <xsd:element name="siteArea" type="siteAreaType" substitutionGroup="site"/>
    <xsd:element name="siteAND" type="siteANDType" substitutionGroup="site"/>
    <xsd:element name="siteOR" type="siteORType" substitutionGroup="site"/>
    <xsd:element name="siteXOR" type="siteXORType" substitutionGroup="site"/>
    <xsd:element name="siteNOT" type="siteNOTType" substitutionGroup="site"/>

    <!-- ELEMENT DECLARATIONS FOR CHANNEL TYPE -->
    <xsd:element name="channel" type="channelType" abstract="true"/>
    <xsd:element name="bandCode" type="bandCodeType" substitutionGroup="channel"/>
    <xsd:element name="gainCode" type="gainCodeType" substitutionGroup="channel"/>
    <xsd:element name="orientationCode" type="orientationCodeType" substitutionGroup="channel"/>
    <xsd:element name="sampling" type="samplingType" substitutionGroup="channel"/>
    <xsd:element name="channelEffectiveTimeOverlap" type="channelEffectiveTimeOverlapType" substitutionGroup="channel"/>
    <xsd:element name="orientationRange" type="orientationRangeType" substitutionGroup="channel"/>
    <xsd:element name="orientationAzimuthRange" type="orientationAzimuthRangeType" substitutionGroup="channel"/>
    <xsd:element name="orientationDipRange" type="orientationDipRangeType" substitutionGroup="channel"/>
    <xsd:element name="channelAND" type="channelANDType" substitutionGroup="channel"/>
    <xsd:element name="channelOR" type="channelORType" substitutionGroup="channel"/>
    <xsd:element name="channelXOR" type="channelXORType" substitutionGroup="channel"/>
    <xsd:element name="channelNOT" type="channelNOTType" substitutionGroup="channel"/>



    <!-- element representing the process -->
    <xsd:element name="networkProcess" type="processType" abstract="true"/>
    <xsd:element name="printlineChannelProcessor" type="printLineChannelProcessorType"  substitutionGroup="networkProcess"/>
    <xsd:element name="externalNetworkProcess" type="externalNetworkProcessType" substitutionGroup="networkProcess"/>

    <xsd:complexType name="networkArmType">
        <xsd:complexContent>
            <xsd:extension base="armType">
                <xsd:sequence>
                    <xsd:element ref="networkSource"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="network"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="station"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="site"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="channel"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="networkProcess" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="networkArm" type="networkArmType"/>


<!--
    <xsd:annotation>
        <xsd:documentation xml:lang="en">
            Schema for the WaveFormArm of SOD
        </xsd:documentation>
    </xsd:annotation>
-->


    <!-- Abstract Type Declarations -->

    <!-- ABSTRACT TYPE EVENT STATION-->
    <xsd:complexType name="eventStationType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all EventStation subsetters.
            </summary>
            <description>
                This is a place holder for EventStation subsetters. See the
                list of known subclasses for subsetters that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE EVENT CHANNEL-->
    <xsd:complexType name="eventChannelType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all EventChannel subsetters.
            </summary>
            <description>
                This is a place holder for EventChannel subsetters. See the
                list of known subclasses for subsetters that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE REQUEST GENERATOR-->
    <xsd:complexType name="requestGeneratorType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all request generators.
            </summary>
            <description>
                This is a place holder for request generators. See the
                list of known subclasses for elements that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE REQUEST GENERATOR-->
    <xsd:complexType name="requestSubsetterType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all request subsetters.
            </summary>
            <description>
                This is a place holder for request subsetter. See the
                list of known subclasses for elements that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE AVAILABLE DATA-->
    <xsd:complexType name="availableDataType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all AvailableData subsetters.
            </summary>
            <description>
                This is a place holder for AvailableData subsetters. See the
                list of known subclasses for subsetters that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE Seismogram-->
    <xsd:complexType name="seismogramType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all Seismogram subsetters.
            </summary>
            <description>
                This is a place holder for Seismogram subsetters. See the
                list of known subclasses for subsetters that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE WAVE FORM-->
    <xsd:complexType name="seismogramProcessType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all seismogram processors.
            </summary>
            <description>
                This is a place holder for seismogram processors. See the
                list of known subclasses for subsetters that can be used.
            </description>
                <example>

                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ABSTRACT TYPE DATA CENTER SOURCE -->
    <xsd:complexType name="dataCenterType" abstract="true">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Abstract superclass of all data centers.
            </summary>
            <description>
                This is a place holder for DataCenters. See the
                list of known subclasses for elements that can be used.
            </description>
            <example>

            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="sourceType"/>
        </xsd:complexContent>
    </xsd:complexType>



    <!-- TYPE DECLARATIONS FOR THE SUBSETTER *****EVENTSTATION***** -->

    <!-- EVENT STATION AND TYPE -->
    <xsd:complexType name="eventStationANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between EventStation subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <eventStationAND>
                        <distanceRange>
                           <unit>DEGREE</unit>
                           <min>40</min>
                        </distanceRange>
                        <backAzimuthRange>
                           <min>30</min>
                           <max>45</max>
                        </backAzimuthRange>
                    </eventStationAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="eventStation" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION OR TYPE -->
    <xsd:complexType name="eventStationORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between EventStation subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. The subsetters after the
                    first true output are not evaluated.
                </description>
                <example>
                    <eventStationOR>
                        <distanceRange>
                            <unit>DEGREE</unit>
                            <min>40</min>
                        </distanceRange>
                        <backAzimuthRange>
                           <min>30</min>
                           <max>45</max>
                        </backAzimuthRange>
                    </eventStationOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="eventStation" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION XOR TYPE -->
    <xsd:complexType name="eventStationXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between EventStation subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included subsetters.
                </description>
                <example>
                    <eventStationXOR>
                        <distanceRange>
                           <unit>DEGREE</unit>
                           <min>40</min>
                        </distanceRange>
                        <backAzimuthRange>
                           <min>30</min>
                           <max>45</max>
                        </backAzimuthRange>
                    </eventStationXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="eventStation" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION NOT TYPE -->
    <xsd:complexType name="eventStationNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an EventStation subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included subsetter.
                </description>
                <example>
                    <eventStationNOT>
                        <distanceRange>
                           <unit>DEGREE</unit>
                           <min>40</min>
                        </distanceRange>
                    </eventStationNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="eventStation" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION DISTANCE TYPE -->
    <xsd:complexType name="distanceRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Subsetter based on the distance from the event to station.
                </summary>
                <description>
                   This accepts event station pairs where the distance
                   between the preferred origin to the station is within the
                   range given.
                </description>
                <example>
                   <distanceRange>
                       <unit>DEGREE</unit>
                       <min>30</min>
                       <max>90</max>
                   </distanceRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element name="unit" type="unitType"/>
                    <xsd:element name="min" type="xsd:integer"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="max" type="xsd:integer"  minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EMBEDDED ORIGIN TYPE -->
    <xsd:complexType name="embeddedOriginSubsetterType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Allows the embeedding of an origin subsetter into a
                   EventStation location.
                </summary>
                <description>
                   Allows the embeedding of an origin subsetter into a
                   EventStation location. This is mainly used with an AND or OR
                   where one condition only depends on the origin.
                </description>
                <example>
                   <embeddedOriginSubsetter>
                      <magnitudeRange>
                          <min>5.5</min>
                      </magnitudeRange>
                   </embeddedOriginSubsetter>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="origin"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION STATION TYPE -->
    <xsd:complexType name="embeddedStationSubsetterType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Allows the embeedding of an station subsetter into a
                   EventStation location.
                </summary>
                <description>
                   Allows the embeedding of an station subsetter into a
                   EventStation location. This is mainly used with an AND or OR
                   where one condition only depends on the station.
                </description>
                <example>
                   <embeddedStationSubsetter>
                    <stationDepthRange>
                        <unitRange>
                            <unit>METER</unit>
                            <min>100</min>
                            <max>200</max>
                        </unitRange>
                    </stationDepthRange>
                   </embeddedStationSubsetter>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="station"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION AZIMUTH RANGE TYPE -->
    <xsd:complexType name="azimuthRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Subsetter based on the azimuth from the event to station.
                </summary>
                <description>
                   This accepts event station pairs where the azimuth
                   from the preferred origin to the station is within the
                   range given in degrees.
                </description>
                <example>
                   <azimuthRange>
                       <unit>DEGREE</unit>
                       <min>30</min>
                       <max>90</max>
                   </azimuthRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element name="min" type="xsd:float"/>
                    <xsd:element name="max" type="xsd:float"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- EVENT STATION BACK AZIMUTH RANGE TYPE -->
    <xsd:complexType name="backAzimuthRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Subsetter based on the back azimuth from the station to the event.
                </summary>
                <description>
                   This accepts event station pairs where the azimuth
                   from the station to the preferred origin is within the
                   range given in degrees.
                </description>
                <example>
                   <backAzimuthRange>
                       <unit>DEGREE</unit>
                       <min>30</min>
                       <max>90</max>
                   </backAzimuthRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element name="min" type="xsd:float"/>
                    <xsd:element name="max" type="xsd:float"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION BACK LINEAR DISTANCE MAGNITUDE RANGE TYPE -->
    <xsd:complexType name="linearDistanceMagnitudeRangeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                   Accepts event stations pairs above a linear threshold of magnitude with distance.
                </summary>
                <description>
                   If the magnitude of the event is greater than or equal to
                   the linear interpolation at the event station distance, then
                   the event statino pair is accepted. To reverse and take
                   events smaller than the linear interpolation, enclose
                   this in an EventStationNOT.
                </description>
                <example>
                   <linearDistanceMagnitudeRange>
                      <magnitudeRange>
                          <magType>mb</magType>
                          <magType>M</magType>
                          <min>5.5</min>
                      </magnitudeRange>
                       <unit>DEGREE</unit>
                       <min>30</min>
                       <max>90</max>
                   </linearDistanceMagnitudeRange>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element ref="magnitudeRange"/>
                    <xsd:element name="unit" type="unitType"/>
                    <xsd:element name="min" type="xsd:integer"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="max" type="xsd:integer"  minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- PHASE TURN INTERACTION TYPE -->
    <xsd:simpleType name="phaseTurnInteractionType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="TOPSIDE REFLECTION"/>
            <xsd:enumeration value="BOTTOMSIDE REFLECTION"/>
            <xsd:enumeration value="TURNPOINT"/>
            <xsd:enumeration value="UPGOING S TO P CONVERSION"/>
            <xsd:enumeration value="UPGOING P TO S CONVERSION"/>
            <xsd:enumeration value="DOWNGOING S TO P CONVERSION"/>
            <xsd:enumeration value="DOWNGOING P TO S CONVERSION"/>
            <xsd:enumeration value="PATH"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- ABSTRACT TYPE PHASE TYPE -->
    <xsd:complexType name="phaseAbstractType"  abstract="true">
        <xsd:complexContent>
            <xsd:extension base="eventStationType">
                <xsd:sequence>
                    <xsd:element name="modelName" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="phaseName" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION PHASE EXISTS TYPE -->
    <xsd:complexType name="phaseExistsType">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Accepts a event-station pair if the given phase exists.
            </summary>
            <description>
                Accepts a event-station pair if the given phase exists.
            </description>
            <example>
               <phaseExists>
              <modelName>prem</modelName>
                  <phaseName>P</phaseName>
               </phaseExists>
            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="phaseAbstractType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- EVENT STATION PHASE INTERACTION TYPE -->
    <xsd:complexType name="phaseInteractionAbstractType"  abstract="true">
        <xsd:complexContent>
            <xsd:extension base="phaseAbstractType">
                <xsd:sequence>
                    <xsd:element name="interactionStyle" type="phaseTurnInteractionType"/>
                    <xsd:element name="interactionNumber" type="xsd:positiveInteger" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- PHASE RELATIVE ABSOLUTE ABSTRACT TYPE -->
    <xsd:complexType name="phaseRelativeAbsoluteAbstractType" abstract="true"/>


    <!-- PHASE RELATIVE TYPE -->
    <xsd:complexType name="phaseInteractionRelativeType">
        <xsd:complexContent>
            <xsd:extension base="phaseRelativeAbsoluteAbstractType">
                <xsd:sequence>
                    <xsd:element name="reference" type="phaseDistanceReferenceType"/>
                    <xsd:element ref="area" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="depthRange" minOccurs="0" maxOccurs="unbounded">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="unitRange" type="unitRangeType"/>
                            </xsd:sequence>
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element ref="distanceRange" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION PHASE INTERACTION ABSOLUTE TYPE -->
    <xsd:complexType name="phaseInteractionAbsoluteType">
        <xsd:complexContent>
            <xsd:extension base="phaseRelativeAbsoluteAbstractType">
                <xsd:sequence>
                    <xsd:element ref="area" minOccurs="0"  maxOccurs="0"/>
                    <xsd:element name="depthRange" minOccurs="0" maxOccurs="0">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="unitRange" type="unitRangeType"/>
                            </xsd:sequence>
                        </xsd:complexType>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT STATION PHASE INTERACTION TYPE -->
    <xsd:complexType name="phaseInteractionType">
        <xsd:complexContent>
            <xsd:extension base="phaseInteractionAbstractType">
                <xsd:sequence>
                    <xsd:element ref="phaseRelativeAbsolute" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- PHASE DISTANCE REFERENCE TYPE -->
    <xsd:simpleType name="phaseDistanceReferenceType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="EVENT"/>
            <xsd:enumeration value="STATION"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- TYPE DECLARATIONS FOR THE SUBSETTER *****EVENTCHANNEL***** -->

    <!-- EMBEDDED EVENT STATION TYPE -->
    <xsd:complexType name="embeddedEventStationType">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Allows an event station subsetter to be embedded within a
        event channel subsetter.
            </summary>
            <description>
                Allows an event station subsetter to be embedded within a
        event channel subsetter. The is most often used within
        an EventChannel logical subsetter.
            </description>
            <example>
               <embeddedEventStation>
                     <distanceRange>
                        <unit>DEGREE</unit>
                        <min>40</min>
                     </distanceRange>
               </embeddedEventStation>
            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventChannelType">
                <xsd:sequence>
                    <xsd:element ref="eventStation" />
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EMBEDDED CHANNEL TYPE -->
    <xsd:complexType name="embeddedChannelType">
      <xsd:annotation>
    <xsd:documentation xml:lang="en">
            <summary>
                Allows a Channel subsetter to be embedded within an
        EventChannel.
            </summary>
            <description>
                Allows a Channel subsetter to be embedded within an
        EventChannel. This is most often used within a EventChannel
                logical.
            </description>
            <example>
        <embeddedChannel>
                <sampling>
                    <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
        </embeddedChannel>
            </example>
    </xsd:documentation>
      </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventChannelType">
                <xsd:sequence>
                    <xsd:element ref="channel" />
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- EVENT CHANNEL AND TYPE -->
    <xsd:complexType name="eventChannelANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between EventChannel subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <eventChannelAND>
                        <embeddedEventStation>
                           <distanceRange>
                              <unit>DEGREE</unit>
                              <min>40</min>
                           </distanceRange>
                        </embeddedEventStation>
                        <embeddedChannel>
                           <bandCode>B</bandCode>
                        </embeddedChannel>
                    </eventChannelAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventChannelType">
                <xsd:sequence>
                    <xsd:element ref="eventChannel" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT CHANNEL OR TYPE -->
    <xsd:complexType name="eventChannelORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between EventChannel subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. The subsetters after the
                    first true outputed are not evaluated.
                </description>
                <example>
                    <eventChannelOR>
                        <embeddedEventStation>
                           <distanceRange>
                              <unit>DEGREE</unit>
                              <min>40</min>
                           </distanceRange>
                        </embeddedEventStation>
                        <embeddedChannel>
                           <bandCode>B</bandCode>
                        </embeddedChannel>
                    </eventChannelOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventChannelType">
                <xsd:sequence>
                    <xsd:element ref="eventChannel" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT CHANNEL XOR TYPE -->
    <xsd:complexType name="eventChannelXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between EventChannel subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of
                    included subsetters.
                </description>
                <example>
                    <eventChannelXOR>
                        <embeddedEventStation>
                           <distanceRange>
                              <unit>DEGREE</unit>
                              <min>40</min>
                           </distanceRange>
                        </embeddedEventStation>
                        <embeddedChannel>
                           <bandCode>B</bandCode>
                        </embeddedChannel>
                    </eventChannelXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventChannelType">
                <xsd:sequence>
                    <xsd:element ref="eventChannel" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- EVENT CHANNEL NOT TYPE -->
    <xsd:complexType name="eventChannelNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an EventChannel subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of the
                    included subsetter.
                </description>
                <example>
                    <eventChannelNOT>
                        <embeddedEventStation>
                           <distanceRange>
                              <unit>DEGREE</unit>
                              <min>40</min>
                           </distanceRange>
                        </embeddedEventStation>
                    </eventChannelNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="eventChannelType">
                <xsd:sequence>
                    <xsd:element ref="eventChannel" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- TYPE DECLARATIONS FOR THE SUBSETTER *****DATA CENTER***** -->

    <!-- DATA CENTER FIXED DATA CENTER TYPE -->
    <xsd:complexType name="fixedDataCenterType">
        <xsd:complexContent>
            <xsd:extension base="dataCenterType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- TYPE DECLARATIONS FOR THE SUBSETTER REQUESTGENERATOR********** -->

    <!-- REQUEST GENERATOR PHASE REQUEST TYPE -->
    <xsd:complexType name="phaseRequestType">
        <xsd:complexContent>
            <xsd:extension base="requestGeneratorType">
                <xsd:sequence>
                    <xsd:element name="model" type="xsd:string" minOccurs="0"/>
                    <xsd:element name="beginPhase" type="xsd:string"/>
                    <xsd:element name="beginOffset" type="timeIntervalType"/>
                    <xsd:element name="endPhase" type="xsd:string"/>
                    <xsd:element name="endOffset" type="timeIntervalType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- REQUEST GENERATOR CHOICE REQUEST TYPE -->

    <!-- ABSTRACT TYPE ChoicePartType-->
    <xsd:complexType name="choicePartType" abstract="true">
            <xsd:sequence>
               <xsd:element ref="requestGenerator" />
            </xsd:sequence>
    </xsd:complexType>

    <xsd:element name="choicePart" type="choicePartType" abstract="true" />

    <xsd:element name="eventStationChoice" substitutionGroup="choicePart" >
        <xsd:complexType>
          <xsd:complexContent>
              <xsd:extension base="choicePartType">
                 <xsd:sequence>
                 <xsd:element ref="eventStation" />
                 </xsd:sequence>
              </xsd:extension >
          </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="eventChannelChoice" substitutionGroup="choicePart" >
        <xsd:complexType>
        <xsd:complexContent>
            <xsd:extension base="choicePartType">
<xsd:sequence>
               <xsd:element ref="eventChannel" />
 </xsd:sequence>
            </xsd:extension >
        </xsd:complexContent>
    </xsd:complexType>
    </xsd:element>

    <xsd:complexType name="choiceRequestType">
        <xsd:complexContent>
            <xsd:extension base="requestGeneratorType">
                <xsd:sequence>
                    <xsd:element ref="choicePart" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="otherwise" minOccurs="0">
                       <xsd:complexType>
                             <xsd:sequence>
                                <xsd:element ref="requestGenerator" />
                             </xsd:sequence>
                       </xsd:complexType>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- TYPE DECLARATIONS FOR THE SUBSETTER *****REQUEST SUBSETTER***** -->

    <!-- REQUEST SUBSETTER AND TYPE -->
    <xsd:complexType name="requestSubsetterANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between RequestSubsetter subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <requestSubsetterAND>
                       <something/>
                       <somethingelse/>
                    </requestSubsetterAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="requestSubsetterType">
                <xsd:sequence>
                    <xsd:element ref="requestSubsetter" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- REQUEST SUBSETTER OR TYPE -->
    <xsd:complexType name="requestSubsetterORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between RequestSubsetter subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. The subsetters after the
                    first true outputed are not evaluated.
                </description>
                <example>
                    <requestSubsetterOR>
                       <something/>
                       <somethingelse/>
                    </requestSubsetterOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="requestSubsetterType">
                <xsd:sequence>
                    <xsd:element ref="requestSubsetter" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- REQUEST SUBSETTER XOR TYPE -->
    <xsd:complexType name="requestSubsetterXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between RequestSubsetter subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included subsetters.
                </description>
                <example>
                    <requestSubsetterXOR>
                       <something/>
                       <somethingelse/>
                    </requestSubsetterXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="requestSubsetterType">
                <xsd:sequence>
                    <xsd:element ref="requestSubsetter" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- REQUEST SUBSETTER NOT TYPE -->
    <xsd:complexType name="requestSubsetterNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an RequestSubsetter subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of
                    the included subsetters.
                </description>
                <example>
                    <requestSubsetterNOT>
                       <something/>
                    </requestSubsetterNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="requestSubsetterType">
                <xsd:sequence>
                    <xsd:element ref="requestSubsetter" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- TYPE DECLARATIONS FOR THE SUBSETTER *****AVAILABLE DATA***** -->

    <!-- AVAILABLE DATA AND TYPE -->
    <xsd:complexType name="availableDataANDType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical AND between AvailableData subsetters.
                </summary>
                <description>
                    The output is the logical AND of the outputs of all
                    included subsetters. The subsetters after the
                    first false outputed are not evaluated.
                </description>
                <example>
                    <availableDataAND>
                       <nogaps/>
                       <fullCoverage/>
                    </availableDataAND>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                    <xsd:element ref="availableData" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AVAILABLE DATA OR TYPE -->
    <xsd:complexType name="availableDataORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical OR between AvailableData subsetters.
                </summary>
                <description>
                    The output is the logical OR of the outputs of all
                    included subsetters. The subsetters after the
                    first true outputed are not evaluated.
                </description>
                <example>
                    <availableDataOR>
                       <nogaps/>
                       <fullCoverage/>
                    </availableDataOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                    <xsd:element ref="availableData" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AVAILABLE DATA XOR TYPE -->
    <xsd:complexType name="availableDataXORType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical XOR between AvailableData subsetters.
                </summary>
                <description>
                    The output is the logical XOR of the outputs of all
                    included subsetters.
                </description>
                <example>
                    <availableDataXOR>
                       <nogaps/>
                       <fullCoverage/>
                    </availableDataXOR>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                    <xsd:element ref="availableData" minOccurs="2" maxOccurs="2"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AVAILABLE DATA NOT TYPE -->
    <xsd:complexType name="availableDataNOTType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Logical NOT of an AvailableData subsetter.
                </summary>
                <description>
                    The output is the logical NOT of the output of
                    the included subsetters.
                </description>
                <example>
                    <availableDataNOT>
                       <nogaps/>
                    </availableDataNOT>
                </example>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                    <xsd:element ref="availableData" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AVAILABLE DATA NO GAPS TYPE -->
    <xsd:complexType name="nogapsType">
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AVAILABLE DATA FULL COVERAGE TYPE -->
    <xsd:complexType name="fullCoverageType">
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- AVAILABLE DATA SOME COVERAGE TYPE -->
    <xsd:complexType name="someCoverageType">
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- TYPE DECLARATIONS FOR THE PROCESSES AT THE END OF THE WAVE FORM ARM -->

    <xsd:complexType name="externalSeismogramProcessType">
        <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
               <xsd:sequence>
                    <xsd:element name="classname" type="xsd:string"/>
                    <xsd:any processContents="lax"  minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="printLineSeismogramProcessorType">
        <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="phaseCutType">
         <xsd:annotation>
            <xsd:documentation xml:lang="en">
                <summary>
                    Cuts seismograms relative to predicted phase arrival times.
                </summary>
                <description>
        Cuts seismogras relative to offsets from phase arrival time
        predicted by TauP for the model.
                </description>
                <example>
                    <phaseCut>
                       <model>prem</model>
                       <beginPhase>P</beginPhase>
                       <beginOffset>
                  <unit>SECOND</unit>
              <value>-100</value>
               </beginOffset>
                       <endPhase>P</endPhase>
                       <endOffset>
                  <unit>SECOND</unit>
              <value>-100</value>
               </endOffset>
                    </phaseCut>
                </example>
            </xsd:documentation>
        </xsd:annotation>
       <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
                <xsd:sequence>
                    <xsd:element name="model" type="xsd:string" minOccurs="0"/>
                    <xsd:element name="beginPhase" type="xsd:string"/>
                    <xsd:element name="beginOffset" type="timeIntervalType"/>
                    <xsd:element name="endPhase" type="xsd:string"/>
                    <xsd:element name="endOffset" type="timeIntervalType"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="rMeanType">
        <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="rTrendType">
        <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="responseGainProcessorType">
        <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="sacSeismogramProcessType">
        <xsd:complexContent>
            <xsd:extension base="seismogramProcessType">
                <xsd:sequence>
                    <xsd:element name="dataDirectory" type="xsd:string"/>
                    <xsd:element name="eventDirLabel" type="eventLabelType" minOccurs="0" />
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="statusProcessType" abstract="true" >
        <xsd:complexContent>
            <xsd:extension base="subsetterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="HTMLStatusProcessType">
        <xsd:complexContent>
            <xsd:extension base="statusProcessType">
                <xsd:sequence>
                    <xsd:element name="filename" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>



    <xsd:complexType name="eventLabelType" mixed="true" >
        <xsd:all>
           <xsd:element name="separator" type="xsd:string" minOccurs="0" />
           <xsd:element name="feRegionName" >
              <xsd:complexType />
           </xsd:element>
           <xsd:element name="feRegionNumber" >
              <xsd:complexType />
           </xsd:element>
           <xsd:element name="depth" >
              <xsd:complexType />
           </xsd:element>
           <xsd:element name="magnitude" >
              <xsd:complexType />
           </xsd:element>
           <xsd:element name="latitude" >
              <xsd:complexType />
           </xsd:element>
           <xsd:element name="longitude" >
              <xsd:complexType />
           </xsd:element>
           <xsd:element name="originTime" type="xsd:string" />
        </xsd:all>
    </xsd:complexType >

    <xsd:complexType name="breqfastAvailableDataType">
        <xsd:complexContent>
            <xsd:extension base="availableDataType">
                <xsd:sequence>
                    <xsd:element name="dataDirectory" type="xsd:string"/>
                    <xsd:element name="label" type="eventLabelType" minOccurs="0" />
                    <xsd:element name="name" type="xsd:string"/>
                    <xsd:element name="inst" type="xsd:string"/>
                    <xsd:element name="mail" type="xsd:string"/>
                    <xsd:element name="email" type="xsd:string"/>
                    <xsd:element name="phone" type="xsd:string"/>
                    <xsd:element name="fax" type="xsd:string"/>
                    <xsd:element name="media" type="xsd:string"/>
                    <xsd:element name="altmedia1" type="xsd:string"/>
                    <xsd:element name="altmedia2" type="xsd:string"/>
                    <xsd:element name="quality" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="breqfastRequestSubsetterType">
        <xsd:complexContent>
            <xsd:extension base="requestSubsetterType">
                <xsd:sequence>
                    <xsd:element name="dataDirectory" type="xsd:string"/>
                    <xsd:element name="label" type="eventLabelType" minOccurs="0" />
                    <xsd:element name="name" type="xsd:string"/>
                    <xsd:element name="inst" type="xsd:string"/>
                    <xsd:element name="mail" type="xsd:string"/>
                    <xsd:element name="email" type="xsd:string"/>
                    <xsd:element name="phone" type="xsd:string"/>
                    <xsd:element name="fax" type="xsd:string"/>
                    <xsd:element name="media" type="xsd:string"/>
                    <xsd:element name="altmedia1" type="xsd:string"/>
                    <xsd:element name="altmedia2" type="xsd:string"/>
                    <xsd:element name="quality" type="xsd:string"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ELEMENT DECLARATIONS -->

    <!-- ELEMENT DECLARATIONS FOR EVENT STATION TYPE -->
    <xsd:element name="eventStation" type="eventStationType" abstract="true"/>
    <xsd:element name="distanceRange" type="distanceRangeType" substitutionGroup="eventStation"/>
    <xsd:element name="embeddedOriginSubsetter" type="embeddedOriginSubsetterType" substitutionGroup="eventStation"/>
    <xsd:element name="embeddedStationSubsetter" type="embeddedStationSubsetterType" substitutionGroup="eventStation"/>
    <xsd:element name="azimuthRange" type="azimuthRangeType" substitutionGroup="eventStation"/>
    <xsd:element name="backAzimuthRange" type="backAzimuthRangeType" substitutionGroup="eventStation"/>
    <xsd:element name="linearDistanceMagnitudeRange" type="linearDistanceMagnitudeRangeType" substitutionGroup="eventStation"/>

    <xsd:element name="phaseRelativeAbsolute" type="phaseRelativeAbsoluteAbstractType" abstract="true"/>
    <xsd:element name="relative" type="phaseInteractionRelativeType" substitutionGroup="phaseRelativeAbsolute"/>
    <xsd:element name="absolute" type="phaseInteractionAbsoluteType" substitutionGroup="phaseRelativeAbsolute"/>
    <xsd:element name="phaseInteraction" type="phaseInteractionType" substitutionGroup="eventStation"/>
    <xsd:element name="phaseExists" type="phaseExistsType" substitutionGroup="eventStation"/>

    <xsd:element name="eventStationAND" type="eventStationANDType" substitutionGroup="eventStation"/>
    <xsd:element name="eventStationOR" type="eventStationORType" substitutionGroup="eventStation"/>
    <xsd:element name="eventStationXOR" type="eventStationXORType" substitutionGroup="eventStation"/>
    <xsd:element name="eventStationNOT" type="eventStationNOTType" substitutionGroup="eventStation"/>

    <!-- ELEMENT DECLARATIONS FOR EVENT CHANNEL TYPE -->
    <xsd:element name="eventChannel" type="eventChannelType" abstract="true"/>
    <xsd:element name="embeddedEventStation" type="embeddedEventStationType" substitutionGroup="eventChannel"/>
    <xsd:element name="embeddedChannel" type="embeddedChannelType" substitutionGroup="eventChannel"/>
    <xsd:element name="eventChannelAND" type="eventChannelANDType" substitutionGroup="eventChannel"/>
    <xsd:element name="eventChannelOR" type="eventChannelORType" substitutionGroup="eventChannel"/>
    <xsd:element name="eventChannelXOR" type="eventChannelXORType" substitutionGroup="eventChannel"/>
    <xsd:element name="eventChannelNOT" type="eventChannelNOTType" substitutionGroup="eventChannel"/>

    <!-- ELEMENT DECLARATIONS FOR DATA CENTER TYPE -->
    <xsd:element name="dataCenter" type="dataCenterType" abstract="true"/>
    <xsd:element name="fixedDataCenter" type="fixedDataCenterType" substitutionGroup="dataCenter"/>

    <!-- ELEMENT DECLARATIONS FOR REQUEST GENERATOR TYPE -->
    <xsd:element name="requestGenerator" type="requestGeneratorType" abstract="true"/>
    <xsd:element name="phaseRequest" type="phaseRequestType" substitutionGroup="requestGenerator"/>

    <!-- ELEMENT DECLARATIONS FOR REQUEST SUBSETTEROR TYPE -->
    <xsd:element name="requestSubsetter" type="requestSubsetterType" abstract="true"/>
    <xsd:element name="requestSubsetterAND" type="requestSubsetterANDType" substitutionGroup="requestSubsetter"/>
    <xsd:element name="requestSubsetterOR" type="requestSubsetterORType" substitutionGroup="requestSubsetter"/>
    <xsd:element name="requestSubsetterXOR" type="requestSubsetterXORType" substitutionGroup="requestSubsetter"/>
    <xsd:element name="requestSubsetterNOT" type="requestSubsetterNOTType" substitutionGroup="requestSubsetter"/>
    <xsd:element name="breqFastRequestSubsetter" type="breqfastRequestSubsetterType" substitutionGroup="requestSubsetter"/>

    <!-- ELEMENT DECLARATIONS FOR AVAILABLE DATA TYPE -->
    <xsd:element name="availableData" type="availableDataType" abstract="true"/>
    <xsd:element name="nogaps" type="nogapsType" substitutionGroup="availableData"/>
    <xsd:element name="fullCoverage" type="fullCoverageType" substitutionGroup="availableData"/>
    <xsd:element name="someCoverage" type="someCoverageType" substitutionGroup="availableData"/>
    <xsd:element name="availableDataAND" type="availableDataANDType" substitutionGroup="availableData"/>
    <xsd:element name="availableDataOR" type="availableDataORType" substitutionGroup="availableData"/>
    <xsd:element name="availableDataXOR" type="availableDataXORType" substitutionGroup="availableData"/>
    <xsd:element name="availableDataNOT" type="availableDataNOTType" substitutionGroup="availableData"/>
    <xsd:element name="breqFastAvailableData" type="breqfastAvailableDataType" substitutionGroup="availableData"/>

    <!-- ELEMENT DECLARATIONS FOR SEISMOGRAM TYPE -->
    <xsd:element name="seismogram" type="seismogramType" abstract="true"/>

    <!-- ELEMENT DECLARATIONS FOR WAVE FORM TYPE -->
    <xsd:element name="seismogramProcess" type="seismogramProcessType" abstract="true"/>

    <!-- element representing the process -->
    <xsd:element name="printlineSeismogramProcess" type="printLineSeismogramProcessorType" substitutionGroup="seismogramProcess"/>
    <xsd:element name="sacFileProcessor" type="sacSeismogramProcessType" substitutionGroup="seismogramProcess"/>
    <xsd:element name="responseGainProcessor" type="responseGainProcessorType" substitutionGroup="seismogramProcess"/>
    <xsd:element name="phaseCut" type="phaseCutType" substitutionGroup="seismogramProcess"/>
    <xsd:element name="rMean" type="rMeanType" substitutionGroup="seismogramProcess"/>
    <xsd:element name="rTrend" type="rTrendType" substitutionGroup="seismogramProcess"/>
    <xsd:element name="externalSeismogramProcess" type="externalSeismogramProcessType" substitutionGroup="seismogramProcess"/>

    <xsd:element name="statusProcess" type="statusProcessType" abstract="true"/>
    <xsd:element name="HTMLStatusProcessor" type="HTMLStatusProcessType"  substitutionGroup="statusProcess"/>

    <xsd:complexType name="localSeismogramArmType">
        <xsd:complexContent>
            <xsd:extension base="armType">
                <xsd:sequence>
                    <xsd:element ref="eventChannel"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="requestGenerator"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="requestSubsetter"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="dataCenter"  minOccurs="1" maxOccurs="1"/>
                    <xsd:element ref="availableData"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="seismogram" minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="seismogramProcess" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="localSeismogramArm" type="localSeismogramArmType"/>

    <xsd:complexType name="waveFormArmType">
        <xsd:complexContent>
            <xsd:extension base="armType">
                <xsd:sequence>
                    <xsd:element ref="eventStation"  minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="localSeismogramArm"/>

                    <xsd:element ref="statusProcess" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="waveFormArm" type="waveFormArmType"/>


</xsd:schema>
