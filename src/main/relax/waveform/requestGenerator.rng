<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
    xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <start combine="choice">
        <ref name="requestGenerator"/>
    </start>
    <define name="requestGenerator">
        <choice>
            <xsd:annotation>
                <summary>Ingredients that generating requests to the seismogram servers</summary>
                <velocity>#waveformArmPage()</velocity>
            </xsd:annotation>
            <ref name="phaseRequest"/>
            <ref name="originOffsetRequest"/>
            <ref name="choiceRequest"/>
            <ref name="combineRequest"/>
            <ref name="requestGeneratorScript"/>
        </choice>
    </define>
    <define name="phaseRequest">
        <element name="phaseRequest">
            <xsd:annotation>
                <summary>Generates requests based on phases</summary>
                <description>This generates requests based on the times relative to calculated phase arrivals.
                See the documentation for the TauP Toolkit, http://www.seis.sc.edu/TauP for the phase naming
                convention. SOD uses the TauP Toolkit internally. The begin and end phase can be a comma
                separated list. If there are multiple arrivals for the phases, then the time will be calculated
                relative to the first arriving phase. If there are zero arrivals for the phases, then
                no request will be generated and no data will be retrieved. The
                phase name "origin" may be used to express an offset from the
                origin time.
                </description>
            </xsd:annotation>
            <ref name="phaseWindow"/>
        </element>
    </define>
    <define name="originOffsetRequest">
        <element name="originOffsetRequest">
            <xsd:annotation>
                <summary>Generates a request for a time window around the origin</summary>
                <description>This generates requests for a certain window around the time the
                    event occured.</description>
                <example>
                    <originOffsetRequest>
                        <beginOffset>
                            <unit>MINUTE</unit>
                            <value>-20</value>
                        </beginOffset>
                        <endOffset>
                            <unit>HOUR</unit>
                            <value>1</value>
                        </endOffset>
                    </originOffsetRequest>
                </example>
            </xsd:annotation>
            <element name="beginOffset">
                <ref name="timeInterval"/>
            </element>
            <element name="endOffset">
                <ref name="timeInterval"/>
            </element>
        </element>
    </define>
    <define name="choiceRequest">
        <element name="choiceRequest">
            <xsd:annotation>
                <summary>Generates requests based on the first event-channel match.</summary>
                <description>This generates requests for the first embedded request generator whose Event-Channel subsetter matches.
                 This allows different time windows based on magnitude or distance from the station. 
                </description>
            </xsd:annotation>
            <oneOrMore>
                <element name="choice">
                    <ref name="eventChannelPlus"/>
                    <ref name="requestGenerator"/>
                </element>
            </oneOrMore>
            <optional>
                <element name="otherwise">
                    <ref name="requestGenerator"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="combineRequest">
        <element name="combineRequest">
            <xsd:annotation>
                <summary>Combines requests from several sub-generators.</summary>
                <description>This combines the requests generated by the embedded request generators.
                 This allows multiple time windows to be processed at once. 
                </description>
            </xsd:annotation>
            <oneOrMore>
                <ref name="requestGenerator"/>
            </oneOrMore>
        </element>
    </define>
    <define name="requestGeneratorScript">
        <element name="requestGeneratorScript">
            <xsd:annotation>
                <summary>Runs a script to generate the request</summary>
                <description>Runs a request generater script via JSR223. The event is put as "event" and the channel
                as "channel". The channel and event objects are a
                VelocityChannel and VelocityEvent, respectively, the same classes used in the <a href="templates.html">templates</a> for the printlineChannelProcess.
                The result is expected to be put as "request" by the script as a List or an array of RequestFilter objects.
                See the <a href="../scripting.html">scripting tutorial</a> for more information on inlining scripts
                into a SOD recipe.</description>
                <example>
                    <requestGeneratorScript type="jython">
                       from java.util import ArrayList
                       from edu.iris.Fissures.IfSeismogramDC import RequestFilter
                       from edu.iris.Fissures.model import TimeInterval, UnitImpl
                       window = TimeInterval(5, UnitImpl.MINUTE)
                       rf = RequestFilter(channel.id,
                                          event.preferred.fissuresTime,
                                          event.preferred.time.add(window).getFissuresTime())
                       result = ArrayList()
                       result.add(rf)
                    </requestGeneratorScript>
                </example>
            </xsd:annotation>
            <attribute name="type">
                    <text/>
            </attribute>
            <data type="string"/>
        </element>
    </define>
</grammar>
