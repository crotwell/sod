<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes" xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <start>
        <ref name="seismogramProcess"/>
    </start>
    <include href="../base/include/eventLabel.rng"/>
    <include href="../base/include/quantity.rng"/>
    <include href="../base/include/range.rng"/>
    <include href="../base/include/taup.rng"/>
    <include href="../base/include/seismogramImage.rng"/>
    <include href="../base/include/seismogramDisplay.rng"/>
    <include href="../base/include/samplingRange.rng"/>
    <define name="seismogramProcess">
        <choice>
            <xsd:annotation>
                <summary>All of the items that process seismograms</summary>
                <description>At this point in the waveform arm, data has been retrieved. Therefore, these items all work
                    on the received data. Some of them like rMean and rTrend perform manipulations on the data. Others
                    like sacWriter and seismogramImageProcess write out information based on the data. Some
                    like fullDataCoverage and phaseSignalToNoise subset the items based on the data&apos;s
                    properties. If several items are used, the data from each step feeds into the next. So if a
                    seismogramImageProcessor follows a phaseCut the image drawn will be of the data after the cut. If
                    you don&apos;t want a processor&apos;s work to effect later steps use the forkProcess to
                    isolate it.</description>
                <include/>
                <velocity>#waveformArmPage()</velocity>
            </xsd:annotation>
            <ref name="printlineSeismogramProcess"/>
            <ref name="sacWriter"/>
            <ref name="mseedWriter"/>
            <ref name="recordSectionDisplayGenerator"/>
            <ref name="responseGain"/>
            <ref name="phaseCut"/>
            <ref name="merge"/>
            <ref name="gapFill"/>
            <ref name="rMean"/>
            <ref name="rTrend"/>
            <ref name="taper"/>
            <ref name="externalWaveformProcess"/>
            <ref name="jythonWaveformProcess"/>
            <ref name="seismogramScript"/>
            <ref name="localSeismogramStatus"/>
            <ref name="filter"/>
            <ref name="forkProcess"/>
            <ref name="alwaysSuccess"/>
            <ref name="phaseSignalToNoise"/>
            <ref name="compoundPhaseSignalToNoise"/>
            <ref name="seismogramImageProcess"/>
            <ref name="legacyExecute"/>
            <ref name="seismogramAND"/>
            <ref name="seismogramOR"/>
            <ref name="seismogramNOT"/>
            <ref name="someDataCoverage"/>
            <ref name="noDataGaps"/>
            <ref name="fullDataCoverage"/>
            <ref name="integrate"/>
            <ref name="differentiate"/>
            <ref name="embeddedNetwork"/>
            <ref name="embeddedStation"/>
            <ref name="embeddedChannel"/>
            <ref name="embeddedEventStation"/>
            <ref name="embeddedEventChannel"/>
            <ref name="embeddedRequest"/>
            <ref name="embeddedEventStationProcessor"/> <!--depricated-->
            <ref name="embeddedEventChannelProcessor"/> <!--depricated-->
            <ref name="transferResponse"/>
            <ref name="collapseOverlaps"/>
            <ref name="div"/>
            <ref name="mul"/>
            <ref name="invertFlippedChannels"/>
            <ref name="seismogramSampling"/>
            <ref name="decimate"/>
            <ref name="compressionType"/>
            <ref name="SNEPProblem"/>
        </choice>
    </define>
    <define name="seismogramAND">
        <element name="seismogramAND">
            <xsd:annotation>
                <summary>Matches all included seismogram processors</summary>
                <description>The output is the logical AND of the outputs of all included seismogram processors. This
                    means that it will evaluate to true only if all of the included processors evaluate to true. The
                    subsetters after the first false outputted are not evaluated. The result of each processor in the
                    AND is passed to the next processor in the AND, and the result of the last evaluated processor in
                    the AND is passed to the next processor outside of the AND. To isolate the processing inside the
                    AND, wrap it inside of a forkProcess.</description>
                <example>
                    <seismogramAND>
                        <noDataGaps/>
                        <fullDataCoverage/>
                    </seismogramAND>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="seismogramOR">
        <element name="seismogramOR">
            <xsd:annotation>
                <summary>Matches at least one of the included seismogram processors</summary>
                <description>The output is the logical OR of the outputs of all included seismogram processors. This
                    means that it will evaluate to true as long as one of the included seismogram processors evaluate to
                    true. The processors after the first true outputted are not evaluated. The result of each processor
                    in the OR is passed to the next processor in the OR, and the result of the last evaluated processor
                    in the OR is passed to the next processor outside of the OR. To isolate the processing inside the
                    OR, wrap it inside of a forkProcess.</description>
                <example>
                    <seismogramOR>
                        <noDataGaps/>
                        <someDataCoverage/>
                    </seismogramOR>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="seismogramNOT">
        <element name="seismogramNOT">
            <xsd:annotation>
                <summary>Matches the negated output of the included seismogram processor</summary>
                <description>The output is the logical NOT of the output of the included seismogram processor. This
                    means that it will evaluate to true if the included processor evaluates to false, and vice versa.
                    The seismic data passed down the chain is the data passed in. The result of each processor in the
                    NOT is passed to the next processor in the NOT, and the result of the last evaluated processor in
                    the NOT is passed to the next processor outside of the NOT. To isolate the processing inside the
                    NOT, wrap it inside of a forkProcess.</description>
                <example>
                    <seismogramNOT>
                        <someDataCoverage/>
                    </seismogramNOT>
                </example>
            </xsd:annotation>
            <ref name="seismogramProcess"/>
        </element>
    </define>
    <define name="phaseCut">
        <element name="phaseCut">
            <xsd:annotation>
                <summary>Cuts seismograms relative to predicted phase arrival times</summary>
                <description>Cuts seismograms relative to offsets from phase arrival time predicted by TauP for the model.</description>
                <example>
                    <phaseCut>
                        <model>prem</model>
                        <beginPhase>P</beginPhase>
                        <beginOffset>
                            <unit>SECOND</unit>
                            <value>-100</value>
                        </beginOffset>
                        <endPhase>P</endPhase>
                        <endOffset>
                            <unit>SECOND</unit>
                            <value>100</value>
                        </endOffset>
                    </phaseCut>
                </example>
            </xsd:annotation>
            <ref name="phaseWindow"/>
        </element>
    </define>
    <define name="requestCut">
        <element name="requestCut">
            <xsd:annotation>
                <summary>Cuts seismograms to the requested window</summary>
                <description>If the seismogram server is returning extra data around the request, this trims it to the
                    time generated by the request generator</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="merge">
        <element name="merge">
            <xsd:annotation>
                <summary>Joins multiple seismograms into a single seismogram if they're contiguous</summary>
                <description>If the seismogram server is returning multiple continuous seismograms for a request, this
                    will join them into a single seismogram. Continuous means that the begin time of the second seismogram
                    is approximately one sample period after the end time of the first seismogram. 
                    This processor does not merge overlapping seismograms or seismograms where there
                    is a gap larger than one sample period. For those cases see collapseOverlaps and gapFill.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="gapFill">
        <element name="gapFill">
            <xsd:annotation>
                <summary>Joins multiple seismograms into a single seismogram by filling gaps</summary>
                <description>If the seismogram server is returning multiple continuous seismograms for a request, this
                    will join them into a single seismogram filling any gaps. This implicitly does a collapseOverlaps and a merge before filling gaps.</description>
            </xsd:annotation>
            
            <choice>
                <element name="zeroFill"> <empty/> </element>
                <element name="linearFill"> <empty/> </element>
            </choice>
        </element>
    </define>
    <define name="filter">
        <element name="filter">
            <xsd:annotation>
                <summary>Apply a Butterworth filter</summary>
                <description>Applies a Butterworth filter to the seismograms. The filterType can be CAUSAL or NONCAUSAL
                    or TWOPASS, with the last two being equivalent.</description>
            </xsd:annotation>
            <element name="lowFreqCorner">
                <xsd:annotation>
                    <example>
                        <lowFreqCorner>
                            <value>50</value>
                            <unit>SECOND</unit>
                        </lowFreqCorner>
                    </example>
                </xsd:annotation>
                <ref name="cornerSetting"/>
            </element>
            <element name="highFreqCorner">
                <xsd:annotation>
                    <example>
                        <highFreqCorner>
                            <value>5</value>
                            <unit>HERTZ</unit>
                        </highFreqCorner>
                    </example>
                </xsd:annotation>
                <ref name="cornerSetting"/>
            </element>
            <element name="numPoles">
                <data type="integer">
                    <xsd:annotation>
                        <example>2</example>
                    </xsd:annotation>
                </data>
            </element>
            <element name="filterType">
                <choice>
                    <value>NONCAUSAL</value>
                    <value>CAUSAL</value>
                    <value>TWOPASS</value>
                </choice>
            </element>
        </element>
    </define>
    <define name="cornerSetting">
        <choice>
            <xsd:annotation>
                <summary>Set corners of a filter</summary>
            </xsd:annotation>
            <ref name="time"/>
            <ref name="freq"/>
        </choice>
    </define>
    <define name="rMean">
        <element name="rMean">
            <xsd:annotation>
                <summary>Remove the mean</summary>
                <description>Removes the mean of the seismograms.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="rTrend">
        <element name="rTrend">
            <xsd:annotation>
                <summary>Remove the trend</summary>
                <description>Removes the trend of the seismograms.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="taper">
        <element name="taper">
            <xsd:annotation>
                <summary>Apply a taper</summary>
                <description>Applies a taper to the seismograms. The type can be one of HANNING, HAMMING or COSINE, with
                    HANNING the default. The width is given as a fraction of the seismogram length, and so should be 0.5
                    as otherwise the begin and end taper will overlap each other. 0.05 is the default.</description>
                <example>
                    <taper>
                        <width>.05</width>
                        <type>HANNING</type>
                    </taper>
                </example>
            </xsd:annotation>
            <optional>
                <element name="width">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="type">
                    <choice>
                        <value>HANNING</value>
                        <value>HAMMING</value>
                        <value>COSINE</value>
                    </choice>
                </element>
            </optional>
        </element>
    </define>
    <define name="responseGain">
        <element name="responseGain">
            <xsd:annotation>
                <summary>Response Gain Correction</summary>
                <description>Applies a overall sensitivity from the response to the seismograms. This will convert int
                    or short seismograms into floats to avoid rounding errors that could result in the output
                    seismograms being all zeros. There is no configuration.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="sacWriter">
        <element name="sacWriter">
            <xsd:annotation>
                <summary>Writes sac files from seismograms</summary>
                <description>The seismograms are written to sac files in the location indicated by location. If multiple
                    seismograms are found for a channel seismograms past the first will be written out with a number
                    appended to their file name. ie the second seismogram will be filename.1 and the third will be
                    filename.2. The phaseTimeHeader element will cause the travel time of the given phase to be placed
                    in the sac header corresponding to the tHeader element. tHeader can be 0-9 as well as a. In the case
                    of 0-9, the ray parameter is inserted into the corresponding userX header as rad/sec. In the case of
                    triplicated phases, the arrivalIndex can be used to pick an arrival different from the first.
                    The default is 1, yeilding the first arrival. If this is set to 2, the second arrival is used
                    and if it is set to -1 then the last arrival is used.
                    See the TauP user manual, http://www.seis.sc.edu/TauP, for the phase naming convention.  
                    If the littleEndian element is added to the sacWriter, it will write out sac files in Intel processor style 
                    little endian byte order.  It defaults to writing in big endian order.</description>
                <example>
                    <sacWriter>
                        <workingDir>seismograms</workingDir>
                        <location>${network.code}.${station.code}/${event.filizedTime}/${site.code}.${channel.code}.sac</location>
                        <phaseTimeHeader>
                            <model>prem</model>
                            <phaseName>ttp</phaseName>
                            <tHeader>a</tHeader>
                        </phaseTimeHeader>
                        <phaseTimeHeader>
                            <model>prem</model>
                            <phaseName>tts</phaseName>
                            <tHeader>1</tHeader>
                            <arrivalIndex>2</arrivalIndex>
                        </phaseTimeHeader>
                    </sacWriter>
                </example>
            </xsd:annotation>
            <ref name="seisWriterBase"/>
            <zeroOrMore>
                <element name="phaseTimeHeader">
                    <xsd:annotation>
                        <summary>Inserts estimated arrival times using TauP</summary>
                    </xsd:annotation>
                    <ref name="phaseTimeContents"/>
                </element>
            </zeroOrMore>
            <zeroOrMore>
                <element name="sacHeaderScript">
                    <xsd:annotation>
                        <summary>Runs a script to set arbitrary SAC headers, or do other customization of the SAC file.</summary>
                <example>
                    <sacHeaderScript type="jython" >
                        sac.idep=sac.IDISP
                        sac.ivtyp=sac.IEQ
                        sac.iqual=sac.IGOOD
                     </sacHeaderScript>
                </example>
            </xsd:annotation>
            <attribute name="type">
                    <text/>
            </attribute>
            <data type="string"/>
                </element>
            </zeroOrMore>
            <optional>
                <element name="littleEndian">
                    <empty/>
                </element>
            </optional>
        </element>
    </define>
    <define name="mseedWriter">
        <element name="mseedWriter">
            <xsd:annotation>
                <summary>Writes mseed files from seismograms</summary>
                <description>The seismograms are written to mseed files in the location indicated by location. If
                    multiple seismograms are found for a channel seismograms past the first will be written out with a
                    number appended to their file name. ie the second seismogram will be filename.1 and the third will
                    be filename.2</description>
                <example>
                    <mseedWriter>
                        <workingDir>seismograms</workingDir>
                        <location>${channel.code}/${event.filizedTime}/${network.code}.${station.code}.${site.code}.mseed</location>
                    </mseedWriter>
                </example>
            </xsd:annotation>
            <ref name="seisWriterBase"/>
        </element>
    </define>
    <define name="seisWriterBase">
        <optional>
            <ref name="workingDir"/>
        </optional>
        <optional>
            <ref name="seisFileLocation"/>
        </optional>
        <optional>
            <ref name="writerName"/>
        </optional>
        <optional>
            <element name="storeSeismogramsInDB">
                <empty/>
            </element>
        </optional>
    </define>
    <define name="workingDir">
        <element name="workingDir">
            <xsd:annotation>
                <summary>The base directory for seismogram output</summary>
                <description>The value generated by location is appened to the value in workingDir to make the location
                    to write seismogram files. This defaults to 'seismograms'.</description>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="writerName">
        <element name="name">
            <xsd:annotation>
                <summary>The name of this writer for reference by other processors</summary>
                <description>This only matters to other processors that wish to access the files written by this writer.
                    Things like legacyExecute and sacExecute use the name to find which seismogram writer's seismograms
                    to pass to their command. If there is only one sacWriter or mseedWriter, you can just leave this alone.</description>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="seisFileLocation">
        <element name="location">
            <xsd:annotation>
                <summary>Generates file locations for seismograms</summary>
                <description>This is a <a href="../../templates.html">Velocity template</a> to determine the file name
                    for the seismograms. The template contains a list of <a
                    href="../../templateTypes.html#seismogram">seismogram</a> named seismograms containing all the
                    retrieved seismograms, a list of <a href="../../templateTypes.html#request">request</a> named
                    originalRequests that are the requests generated by your request generator, another list of <a
                    href="../../templateTypes.html#request">request</a> named availableRequests that are the requests
                    the server said were available for retrieval, <a href="../../templateTypes.html#event">event</a>, <a
                    href="../../templateTypes.html#channel">channel</a>, <a
                    href="../../templateTypes.html#site">site</a>, <a
                    href="../../templateTypes.html#station">station</a> and <a
                    href="../../templateTypes.html#net">net</a> variables. If no template element is given, it defaults
                    to "Event_${event.getTime('yyyy_MM_dd_HH_mm_ss')}/${channel.codes}.mseed". The value generated with
                    location is appended to the value in workingDir to make the full location. </description>
                <example>
                    <location>${channel.code}/${event.getTime("yyyy_DDD_HH_mm_ss")}/${network.code}.${station.code}.${site.code}.mseed</location>
                </example>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="phaseTimeContents">
        <interleave>
            <optional>
                <element name="model">
                    <ref name="model"/>
                </element>
            </optional>
            <element name="phaseName">
                <ref name="phaseName"/>
           </element>
            <element name="tHeader">
                <choice>
                    <value>a</value>
                    <value>0</value>
                    <value>1</value>
                    <value>2</value>
                    <value>3</value>
                    <value>4</value>
                    <value>5</value>
                    <value>6</value>
                    <value>7</value>
                    <value>8</value>
                    <value>9</value>
                </choice>
            </element>
            <optional>
                <element name="arrivalIndex">
                    <data type="integer"/>
                </element>
            </optional>
        </interleave>
    </define>
    <define name="recordSectionDisplayGenerator">
        <element name="recordSectionDisplayGenerator">
            <xsd:annotation>
                <summary>Generates the recordsection display for each event</summary>
                <description>Loads seismograms from files created by the sacWriter or mseedWriter processor and generates the
                    recordsection image file</description>
                <example>
                    <recordSectionDisplayGenerator>
                        <id>RecordSection_</id>
                        <fileNameBase>recordSection</fileNameBase>
                        <idealNumberOfSeismograms>10</idealNumberOfSeismograms>
                        <distanceRange>
                            <min>0</min>
                            <max>180</max>
                        </distanceRange>
                        <recordSectionSize>
                            <width>400</width>
                            <height>400</height>
                        </recordSectionSize>
                    </recordSectionDisplayGenerator>
                </example>
            </xsd:annotation>
            <element name="id">
                <data type="string"/>
            </element>
            <optional>
                <element name="writerName">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <ref name="workingDir"/>
            </optional>
            <optional>
                <ref name="seisFileLocation"/>
            </optional>
            <optional>
                <ref name="embeddedEventChannelProcessor"/>
            </optional>
            <optional>
                <element name="fileNameBase">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="idealNumberOfSeismograms">
                    <xsd:annotation>
                        <description>specifies the ideal number of seismograms to include in this record section. If
                            possible, this many evenly spaced seismograms will be included</description>
                    </xsd:annotation>
                    <data type="integer"/>
                </element>
            </optional>
            <optional>
                <element name="maxNumberOfSeismograms">
                    <xsd:annotation>
                        <description>specifies the maximum number of seismograms to include in this record section. If
                            the spacing of the ideal number is less than satisfactory, this many seismograms may be included</description>
                    </xsd:annotation>
                    <data type="integer"/>
                </element>
            </optional>
            <optional>
                <element name="distanceRange">
                    <ref name="degreeRange"/>
                </element>
            </optional>
            <optional>
                <element name="percentSeisHeight">
                    <xsd:annotation>
                        <description>Height of the seismogram as a percentage of recordsection height</description>
                    </xsd:annotation>
                    <data type="double"/>
                </element>
            </optional>
            <optional>
                <ref name="recordSectionSize"/>
            </optional>
            <element name="displayConfig">
                <ref name="recordSectionDisplayContents"/>
            </element>
        </element>
    </define>
    <define name="recordSectionSize">
        <element name="recordSectionSize">
            <xsd:annotation>
                <summary>Specifies the size of the recordsection</summary>
                <description>Specifies the size of the recordsection</description>
                <example>
                    <recordSectionSize>
                        <width>500</width>
                        <height>500</height>
                    </recordSectionSize>
                </example>
            </xsd:annotation>
            <element name="width">
                <data type="integer"/>
            </element>
            <element name="height">
                <data type="integer"/>
            </element>
        </element>
    </define>
    <define name="externalWaveformProcess">
        <element name="externalWaveformProcess">
            <xsd:annotation>
                <summary>Runs an externally defined Java processor</summary>
                <description>$externalWaveformProcessInfo.getRelaxHTML('../../../')</description>
                <example>
                    <externalWaveformProcess>
                        <classname>edu.myuniv.seis.xyz.MySeisProcessor</classname>
                        <dataDirectory>POND_II</dataDirectory>
                        <extraParam>1.7</extraParam>
                    </externalWaveformProcess>
                </example>
            </xsd:annotation>
            <element name="classname">
                <data type="string"/>
            </element>
            <zeroOrMore>
                <externalRef href="../base/externalRef/anyXML.rng"/>
            </zeroOrMore>
        </element>
    </define>
    <define name="seismogramScript">
        <element name="seismogramScript">
            <xsd:annotation>
                <summary>Runs a script waveform subsetter</summary>
                <description>Runs a waveform subsetter script via JSR223. The event is put as "event" and the channel
                as "channel". The channel and event objects are a
                VelocityChannel and VelocityEvent, respectively, the same classes used in the <a href="../../templates.html">templates</a> for the printlineChannelProcess.
                The original request is put as "request" and the returned available data, also as an array of RequestFilter objects,
                is put as "available". The seismograms are put as "seismograms" as an array of LocalSeismogramImpl objects.
                See the <a href="../../scripting.html">scripting tutorial</a> for more information on inlining scripts
                into a SOD recipe.</description>
                <example>
        <seismogramScript type="jython" >
from jarray import array
from bag import rmean, taper, rtrend, stat
from edu.iris.Fissures.seismogramDC import LocalSeismogramImpl

print "Hello Sod: %s"%(channel,)
outSeis = []
for s in seismograms:
    s = rmean(s)
    s = taper(rtrend(s))
    print stat(s)
    print
    outSeis.append(s)
out = array(outSeis, LocalSeismogramImpl)
result = util.waveformResult(True, out)
       </seismogramScript>
                </example>
            </xsd:annotation>
            <attribute name="type">
                    <text/>
            </attribute>
            <data type="string"/>
        </element>
    </define>
    <define name="jythonWaveformProcess">
        <element name="jythonWaveformProcess">
            <xsd:annotation>
                <summary>Runs an externally defined Jython processor</summary>
                <description>$jythonWaveformProcessInfo.getRelaxHTML('../../../')</description>
                <example>
                    <jythonWaveformProcess>
                        <module>helloSod</module>
                        <class>helloSod</class>
                        <dataDirectory>PutItHere</dataDirectory>
                        <extraParam>1.7</extraParam>
                    </jythonWaveformProcess>
                </example>
            </xsd:annotation>
            
            <choice>
                <group>
                    <element name="module">
                        <data type="string"/>
                    </element>
                    <element name="class">
                        <data type="string"/>
                    </element>
                    <zeroOrMore>
                        <externalRef href="../base/externalRef/anyXML.rng"/>
                    </zeroOrMore>
                </group>
                <element name="inline">
                    <data type="string"/>
                </element>
            </choice>
        </element>
    </define>
    <define name="printlineSeismogramProcess">
        <element name="printlineSeismogramProcess">
            <xsd:annotation>
                <summary>Prints a line to std out for each seismogram processed</summary>
                <description>This simply prints a line to standard out or a file for each seismogram to be processed. It
                    can be used as a simple status monitor. Both filename and template are <a
                        href="../../templates.html">Velocity templates</a>. They contain a list of <a
                    href="../../templateTypes.html#seismogram">seismogram</a> named seismograms containing all the
                    retrieved seismograms, a list of <a href="../../templateTypes.html#request">request</a> named
                    originalRequests that are the requests generated by your request generator, another list of <a
                    href="../../templateTypes.html#request">request</a> named availableRequests that are the requests
                    the server said were available for retrieval, <a href="../../templateTypes.html#site">site</a>, <a
                    href="../../templateTypes.html#station">station</a>, <a href="../../templateTypes.html#net">net</a>
                    and <a href="../../templateTypes.html#event">event</a> variables. If no template element is given,
                    it defaults to "Got $seismograms.size() seismograms for $channel.codes for eq on $event.time". If no
                    filename is given, the output goes to standard out.</description>
                <include/>
            </xsd:annotation>
            <interleave>
                <optional>
                    <element name="template">
                        <text/>
                    </element>
                </optional>
                <optional>
                    <element name="filename">
                        <text/>
                    </element>
                </optional>
            </interleave>
        </element>
    </define>
    <define name="localSeismogramStatus">
        <element name="localSeismogramTemplateGenerator">
            <xsd:annotation>
                <summary>Generate HTML status pages about the processed seismograms</summary>
            </xsd:annotation>
            <element name="template">
                <data type="string">
                    <xsd:annotation>
                        <example>jar:edu/sc/seis/sod/data/templates/waveformArm/localSeismogram.xml</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="forkProcess">
        <element name="forkProcess">
            <xsd:annotation>
                <summary>Forks the processing of seismograms</summary>
                <description>This forks the processing of the seismograms so that more than one sequence of processing
                    steps can be applied to the data independently. If another processor follows the fork it gets the
                    seismograms as they went into the fork, but only executes if the items in the fork passed. If you
                    want to execute the items past the fork no matter what, enclose it in an alwaysSuccess tag.</description>
                <example>
                    <forkProcess>
                        <rTrend/>
                        <sacWriter>
                            <workingDir>rTrendData</workingDir>
                            <location>${network.code}.${station.code}/${event.filizedTime}/${site.code}.${channel.code}.sac</location>
                        </sacWriter>
                    </forkProcess>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="alwaysSuccess">
        <element name="alwaysSuccess">
            <xsd:annotation>
                <summary>Executes a subprocessor, but always returns true</summary>
                <description>This executes the enclosed processor, but always returns a success regardless of whether
                    the enclosed processor succeeded or failed.</description>
                <example>
                    <alwaysSuccess>
                        <printlineSeismogramProcess/>
                    </alwaysSuccess>
                </example>
            </xsd:annotation>
            <ref name="seismogramProcess"/>
        </element>
    </define>
    <define name="phaseSignalToNoise">
        <element name="phaseSignalToNoise">
            <xsd:annotation>
                <summary>Accepts or rejects seismograms based on their signal to noise ratio</summary>
                <description>This calculates the signal to noise ratio (short/long) in the time window described by the offsets
                    around the given phases and passes if the ratio is greater than the given ratio. See the documentation
                    for the TauP Toolkit, http://www.seis.sc.edu/TauP for the phase naming convention. SOD uses the TauP
                    Toolkit internally.</description>
                <example>
                    <phaseSignalToNoise>
                        <phaseName>ttp</phaseName>
                        <shortOffsetBegin>
                            <unit>SECOND</unit>
                            <value>-5</value>
                        </shortOffsetBegin>
                        <shortOffsetEnd>
                            <unit>SECOND</unit>
                            <value>5</value>
                        </shortOffsetEnd>
                        <longOffsetBegin>
                            <unit>SECOND</unit>
                            <value>-105</value>
                        </longOffsetBegin>
                        <longOffsetEnd>
                            <unit>SECOND</unit>
                            <value>-5</value>
                        </longOffsetEnd>
                        <ratio>2.5</ratio>
                    </phaseSignalToNoise>
                </example>
            </xsd:annotation>
            <optional>
                <element name="modelName">
                    <data type="string"/>
                </element>
            </optional>
            <element name="phaseName">
                <data type="string"/>
            </element>
            <element name="shortOffsetBegin">
                <ref name="time"/>
            </element>
            <element name="shortOffsetEnd">
                <ref name="time"/>
            </element>
            <element name="longOffsetBegin">
                <ref name="time"/>
            </element>
            <element name="longOffsetEnd">
                <ref name="time"/>
            </element>
            <element name="ratio">
                <data type="float"/>
            </element>
        </element>
    </define>
    <define name="compoundPhaseSignalToNoise">
        <element name="compoundPhaseSignalToNoise">
            <xsd:annotation>
                <summary>Accepts or rejects seismograms based on their signal to noise ratio</summary>
                <description>This calculates the signal to noise ratio (short/long) in the time window described by the offsets
                    around the given phases and passes if the ratio is less than the given ratio. See the documentation
                    for the TauP Toolkit, http://www.seis.sc.edu/TauP for the phase naming convention. SOD uses the TauP
                    Toolkit internally.</description>
                <example>
                    <compoundPhaseSignalToNoise>
                        <phaseName>SKS</phaseName>
                        <shortOffsetBegin>
                            <unit>SECOND</unit>
                            <value>-5</value>
                        </shortOffsetBegin>
                        <shortOffsetEnd>
                            <unit>SECOND</unit>
                            <value>5</value>
                        </shortOffsetEnd>
                        <longPhaseName>ttp</longPhaseName>
                        <longOffsetBegin>
                            <unit>SECOND</unit>
                            <value>-105</value>
                        </longOffsetBegin>
                        <longOffsetEnd>
                            <unit>SECOND</unit>
                            <value>-5</value>
                        </longOffsetEnd>
                        <ratio>2.5</ratio>
                    </compoundPhaseSignalToNoise>
                </example>
            </xsd:annotation>
            <optional>
                <element name="modelName">
                    <data type="string"/>
                </element>
            </optional>
            <element name="phaseName">
                <data type="string"/>
            </element>
            <element name="shortOffsetBegin">
                <ref name="time"/>
            </element>
            <element name="shortOffsetEnd">
                <ref name="time"/>
            </element>
            <element name="longPhaseName">
                <data type="string"/>
            </element>
            <element name="longOffsetBegin">
                <ref name="time"/>
            </element>
            <element name="longOffsetEnd">
                <ref name="time"/>
            </element>
            <element name="ratio">
                <data type="float"/>
            </element>
        </element>
    </define>
    <define name="seismogramImageProcess">
        <element name="seismogramImageProcess">
            <xsd:annotation>
                <summary>Make images of the processed seismograms</summary>
            </xsd:annotation>
            <ref name="seismogramImageBase"/>
            <optional>
                <element name="displayConfig">
                    <ref name="basicSeismogramDisplayContents"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="legacyExecute">
        <element name="legacyExecute">
            <xsd:annotation>
                <summary>Executes an external program.</summary>
                <description>The legacyExecute processor is capable of running existing command line programs. It does
                    this by passing the filename of the seismograms saved by a earlier sacWriter or mseedWriter
                    processor to a program started with Runtime.exec(). </description>
                <example>
                    <legacyExecute>
                        <command>echo</command>
                    </legacyExecute>
                </example>
            </xsd:annotation>
            <optional>
                <element name="writerName">
                    <xsd:annotation>
                        <summary>The name of the writer that wrote the seismograms</summary>
                        <description>sacWriter and mseedWriter have a name element. The files passed to the command here
                            are the ones written by the sacWriter or mseedWriter with this name. Defaults to no name</description>
                    </xsd:annotation>
                    <data type="string"/>
                </element>
            </optional>
            <element name="command">
                <data type="string"/>
            </element>
            <optional>
                <element name="workingDirectory">
                    <data type="string"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="noDataGaps">
        <element name="noDataGaps">
            <xsd:annotation>
                <summary>Only allows seismograms with gapless data through</summary>
                <description>This processor checks the data returned from the dataCenter for gaps larger than the sample
                    period of the instrument. If from the begin time of the earliest piece to the end time of the latest
                    piece there are no gaps in time larger than the sample period, this process passes the data onto the
                    next item in the line.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="someDataCoverage">
        <element name="someDataCoverage">
            <xsd:annotation>
                <summary>Only allows seismograms with data overlapping the original request through</summary>
                <description>This processor checks the data returned from the dataCenter against the request generated
                    by the request generator. If at least one piece of data exists during the time specified by the
                    request generator, this processor passes the data onto the next step.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="fullDataCoverage">
        <element name="fullDataCoverage">
            <xsd:annotation>
                <summary>Only allows seismograms with data covering the entire original request through</summary>
                <description>This processor checks the data returned from the dataCenter for complete coverage of the
                    original request. If from the begin time of the earliest piece is before the start of the request,
                    and the end time of the latest piece is past the end of the request, the data passes. This does not
                    guarantee that there are no gaps in the middle of the request though. To ensure that, combine this
                    processor with a noDataGaps processor in a seismogramAND.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="integrate">
        <element name="integrate">
            <xsd:annotation>
                <summary>Integrates the seismograms, changing velocity to displacement for example.</summary>
                <description>This processor integrates each seismogram, using a integration constant of zero. This can
                    be used to change velocity to displacement. </description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="differentiate">
        <element name="differentiate">
            <xsd:annotation>
                <summary>Takes the derivitive of the seismograms, changing displacement to velocity for example.</summary>
                <description>This processor takes the derivitive with respect to time of each seismogram. This can be
                    used to change displacement to velocity. </description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="embeddedNetwork">
        <element name="embeddedNetwork">
            <xsd:annotation>
                <summary>Allows any network subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="../network/network.rng"/>
        </element>
    </define>
    <define name="embeddedStation">
        <element name="embeddedStation">
            <xsd:annotation>
                <summary>Allows any station subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="../network/station.rng"/>
        </element>
    </define>
    <define name="embeddedChannel">
        <element name="embeddedChannel">
            <xsd:annotation>
                <summary>Allows any  channel subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="../network/channel.rng"/>
        </element>
    </define>
    <define name="embeddedEventStation">
        <element name="embeddedEventChannel">
            <xsd:annotation>
                <summary>Allows any event channel subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="eventStation.rng"/>
        </element>
    </define>
    <define name="embeddedEventChannel">
        <element name="embeddedEventChannel">
            <xsd:annotation>
                <summary>Allows any event channel subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="eventChannel.rng"/>
        </element>
    </define>
    <define name="embeddedRequest">
        <element name="embeddedRequest">
            <xsd:annotation>
                <summary>Allows any request subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="requestSubsetter.rng"/>
        </element>
    </define>
    <define name="embeddedEventStationProcessor"><!-- depricated-->
        <element name="embeddedEventChannelProcessor">
            <xsd:annotation>
                <summary>Allows any event channel subsetter to be embedded here</summary>
                <description>Depricated, use embeddedEventStation</description>
            </xsd:annotation>
            <externalRef href="eventStation.rng"/>
        </element>
    </define>
    <define name="embeddedEventChannelProcessor"><!-- depricated-->
        <element name="embeddedEventChannelProcessor">
            <xsd:annotation>
                <summary>Allows any event channel subsetter to be embedded here</summary>
                <description>Depricated, use embeddedEventChannel</description>
            </xsd:annotation>
            <externalRef href="eventChannel.rng"/>
        </element>
    </define>
    <define name="transferResponse">
        <element name="transferResponse">
            <xsd:annotation>
                <summary>Applies an instrumentation correction as in the transfer command in SAC</summary>
                <description>This calculates and applies the polezero response from the sensor (stage 1) in the response
                    along with the overall gain. Great care should be taken with this processor as the transfer is a
                    spectral division, and is hence inherently unstable. This basically means that if you allow the
                    frequency limits to be too large, specified in lowCut, lowPass, highPass and highCut, you will be
                    dividing one very small number by another very small number, which due to rounding errors may
                    generate very large amplitudes at long periods which are not real. Also, you should almost always
                    apply an rmean and taper before applying transferResponse. The defaults are as in the example below.
                    See the sac <a
                    href="http://www.llnl.gov/sac/SAC_Commands/transfer">manual</a> for more discussion of transfer. </description>
                <example>
                    <transferResponse>
                        <lowCut>0.005</lowCut>
                        <lowPass>0.01</lowPass>
                        <highPass>1e5</highPass>
                        <highCut>1e6</highCut>
                    </transferResponse>
                </example>
            </xsd:annotation>
            <optional>
                <element name="lowCut">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="lowPass">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="highPass">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="highCut">
                    <data type="float"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="collapseOverlaps">
        <element name="collapseOverlaps">
            <xsd:annotation>
                <summary>Collapses overlapping seismograms.</summary>
                <description>This checks for overlapping seismograms. If one seismogram is completely contained in
                    another seismogram, it is removed. If two seismograms overlap partially, then the longer of the two
                    is kept in its entirety and the short is cut to no longer overlap This processor should ideally not
                    be needed, as the server should refrain from returning overlapping data. See
                    http://www.iris.edu/jira/browse/DHI-6 for the status of this in the Pond server. </description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="seismogramSampling">
        <element name="seismogramSampling">
            <xsd:annotation>
                <summary>Matches if the sampling rate of the seismogram is within the range</summary>
                <description>Matches if the sampling rate of the seismogram is within the range. Both the min and max
                    are optional, although at least one must be given to have any effect</description>
                <example>
                    <seismogramSampling>
                        <min>1</min>
                        <max>40</max>
                        <interval>
                            <unit>SECOND</unit>
                            <value>1</value>
                        </interval>
                    </seismogramSampling>
                </example>
            </xsd:annotation>
            <ref name="samplingRange"/>
        </element>
    </define>
    <define name="decimate">
        <element name="decimate">
            <xsd:annotation>
                <summary>Decimates seismograms.</summary>
                <description>This decimates seismograms by the given factor. Any needed low pass filtering should be
                    done before applying this to avoid aliasing. </description>
            </xsd:annotation>
            <data type="integer"/>
        </element>
    </define>
    <define name="div">
        <element name="div">
            <xsd:annotation>
                <summary>Divides each point in the seismogram by the given value</summary>
            </xsd:annotation>
            <data type="float"/>
        </element>
    </define>
    <define name="mul">
        <element name="mul">
            <xsd:annotation>
                <summary>Multiplies each point in the seismogram by the given value</summary>
            </xsd:annotation>
            <data type="float"/>
        </element>
    </define>
    <define name="invertFlippedChannels">
        <element name="invertFlippedChannels">
            <xsd:annotation>
                <summary>If a seismogram's actual orientation is flipped from the orientation of its code, the
                    seismogram is inverted</summary>
                <description>This processor first checks the orientation in the seismogram's channel against its
                    orientation code. If the code implies an orientation reversed from the actual orientation, the
                    seismogram's values are inverted. For example if the seismogram's channel code is BHZ but its
                    orientation is actually downwards, the inversion will be applied. The codes and orientation will
                    disagree if the channel was installed incorrectly and then later discovered. This seems to be the
                    case in roughly 1/10 of existing channels. Since the inversion changes the orientation stored in the
                    channel any further processors that want to use the results of this processor must be contained
                    inside of it. To just check for disagreement between the code and orientation, use the isFlipped
                    channel subsetter.</description>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="compressionType">
        <element name="compressionType">
            <xsd:annotation>
                <summary>Passes a seismogram's data if it is compressed with the given types.</summary>
                <description>This checks the compression algorithm used by the seismograms and passes if each seismogram
                    matches one of the given types. The integers follow the compression types as defined in the SEED
                    manual for blockette 1000.</description>
            </xsd:annotation>
            <oneOrMore>
                <element name="type">
                    <data type="integer"/>
                </element>
            </oneOrMore>
        </element>
    </define>
    <define name="SNEPProblem">
        <element name="SNEPProblem">
            <xsd:annotation>
                <summary>A SNEP-project-specific waveform process that passes data if it is tagged as having a problem.</summary>
                <description>This processor checks the seismograms' properties and passes the data if a property with
                    the name "snep.problem" exists and, optionally, if it is of a specified type. This is only used
                    within the SNEP project and is fairly useless to anyone not working with its data.</description>
            </xsd:annotation>
            <optional>
                <element name="type">
                    <data type="string"/>
                </element>
            </optional>
        </element>
    </define>
</grammar>
