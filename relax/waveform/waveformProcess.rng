<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
    xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <start>
        <ref name="seismogramProcess"/>
    </start>
    <include href="../base/include/eventLabel.rng"/>
    <include href="../base/include/quantity.rng"/>
    <include href="../base/include/range.rng"/>
    <include href="../base/include/seismogramImage.rng"/>
    <include href="../base/include/seismogramDisplay.rng"/>
    <define name="seismogramProcess">
        <choice>
            <xsd:annotation>
                <summary>All of the items that process seismograms</summary>
                <description>At this point in the waveform arm, data has been retrieved. Therefore,
                    these items all work on the received data. Some of them like rMean and rTrend
                    perform manipulations on the data. Others like saveSeismogramToFile and
                    seismogramImageProcess write out information based on the data. Some like
                    fullDataCoverage and phaseSignalToNoise subset the items based on the
                    data&apos;s properties. If several items are used, the data from each step
                    feeds into the next. So if a seismogramImageProcessor follows a phaseCut the
                    image drawn will be of the data after the cut. If you don&apos;t want a
                    processor&apos;s work to effect later steps use the forkProcess to isolate
                    it.</description>
                <include/>
                <velocity>#waveformArmPage()</velocity>
            </xsd:annotation>
            <ref name="vectorSafeProcesses"/>
            <ref name="retryAndContinue"/>
            <ref name="retryAndFail"/>
        </choice>
    </define>
    <define name="vectorSafeProcesses">
        <choice>
            <xsd:annotation>
                <summary>All of the items that process seismograms</summary>
                <description>At this point in the waveform arm, data has been retrieved. Therefore,
                    these items all work on the received data. Some of them like rMean and rTrend
                    perform manipulations on the data. Others like saveSeismogramToFile and
                    seismogramImageProcess write out information based on the data. Some like
                    fullDataCoverage and phaseSignalToNoise subset the items based on the
                    data&apos;s properties. If several items are used, the data from each step
                    feeds into the next. So if a seismogramImageProcessor follows a phaseCut the
                    image drawn will be of the data after the cut. If you don&apos;t want a
                    processor&apos;s work to effect later steps use the forkProcess to isolate
                    it.</description>
                <include/>
                <velocity>#waveformArmPage()</velocity>
            </xsd:annotation>
            <ref name="printlineSeismogramProcess"/>
            <ref name="sacWriter"/>
            <ref name="mseedWriter"/>
            <ref name="recordSectionDisplayGenerator"/>
            <ref name="responseGain"/>
            <ref name="phaseCut"/>
            <ref name="merge"/>
            <ref name="rMean"/>
            <ref name="rTrend"/>
            <ref name="taper"/>
            <ref name="externalWaveformProcess"/>
            <ref name="localSeismogramStatus"/>
            <ref name="filter"/>
            <ref name="forkProcess"/>
            <ref name="alwaysSuccess"/>
            <ref name="phaseSignalToNoise"/>
            <ref name="seismogramImageProcess"/>
            <ref name="legacyExecute"/>
            <ref name="seismogramAND"/>
            <ref name="seismogramOR"/>
            <ref name="seismogramNOT"/>
            <ref name="someDataCoverage"/>
            <ref name="noDataGaps"/>
            <ref name="fullDataCoverage"/>
            <ref name="integrate"/>
            <ref name="embeddedEventChannelProcessor"/>
            <ref name="transferResponse"/>
            <ref name="saveSeismogramToFile"/>
        </choice>
    </define>
    <define name="seismogramAND">
        <element name="seismogramAND">
            <xsd:annotation>
                <summary>Matches all included seismogram processors</summary>
                <description>The output is the logical AND of the outputs of all included seismogram
                    processors. This means that it will evaluate to true only if all of the included
                    processors evaluate to true. The subsetters after the first false outputted are
                    not evaluated. The seismic data passed down the chain is the data passed in.
                    Seismogram results of the contained processors are ignored.</description>
                <example>
                    <seismogramAND>
                        <noDataGaps/>
                        <fullDataCoverage/>
                    </seismogramAND>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="seismogramOR">
        <element name="seismogramOR">
            <xsd:annotation>
                <summary>Matches at least one of the included seismogram processors</summary>
                <description>The output is the logical OR of the outputs of all included seismogram
                    processors. This means that it will evaluate to true as long as one of the
                    included seismogram processors evaluate to true. The processors after the first
                    true outputted are not evaluated. The seismic data passed down the chain is the
                    data passed in. Seismogram results of the contained processors are ignored.</description>
                <example>
                    <seismogramOR>
                        <noDataGaps/>
                        <someDataCoverage/>
                    </seismogramOR>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="seismogramNOT">
        <element name="seismogramNOT">
            <xsd:annotation>
                <summary>Matches the negated output of the included seismogram processor</summary>
                <description>The output is the logical NOT of the output of the included seismogram
                    processor. This means that it will evaluate to true if the included processor
                    evaluates to false, and vice versa. The seismic data passed down the chain is
                    the data passed in. Seismogram results of the contained processors are ignored.</description>
                <example>
                    <seismogramNOT>
                        <someDataCoverage/>
                    </seismogramNOT>
                </example>
            </xsd:annotation>
            <ref name="seismogramProcess"/>
        </element>
    </define>
    <define name="phaseCut">
        <element name="phaseCut">
            <xsd:annotation>
                <summary>Cuts seismograms relative to predicted phase arrival times</summary>
                <description>Cuts seismograms relative to offsets from phase arrival time predicted
                    by TauP for the model. See the documentation for the TauP Toolkit, http://www.seis.sc.edu/TauP for the phase naming
                    convention. SOD uses the TauP Toolkit internally.</description>
                <example>
                    <phaseCut>
                        <model>prem</model>
                        <beginPhase>P</beginPhase>
                        <beginOffset>
                            <unit>SECOND</unit>
                            <value>-100</value>
                        </beginOffset>
                        <endPhase>P</endPhase>
                        <endOffset>
                            <unit>SECOND</unit>
                            <value>-100</value>
                        </endOffset>
                    </phaseCut>
                </example>
            </xsd:annotation>
            <ref name="phaseWindow"/>
        </element>
    </define>
    <define name="requestCut">
        <element name="requestCut">
            <xsd:annotation>
                <summary>Cuts seismograms to the requested window</summary>
                <description>If the seismogram server is returning extra data around the request,
                    this trims it to the time generated by the request generator</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="merge">
        <element name="merge">
            <xsd:annotation>
                <summary>Joins multiple seismograms into a single seismogram if they're contiguous</summary>
                <description>If the seismogram server is returning multiple continuous seismograms for a request, this will join them into a single seismogram</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="filter">
        <element name="filter">
            <xsd:annotation>
                <summary>Apply a Butterworth filter</summary>
                <description>Applies a Butterworth filter to the seismograms. The filterType can be
                    CAUSAL or NONCAUSAL or TWOPASS, with the last two being
                equivalent.</description>
            </xsd:annotation>
            <element name="lowFreqCorner">
                <xsd:annotation>
                    <example>
                        <lowFreqCorner>
                            <value>50</value>
                            <unit>SECOND</unit>
                        </lowFreqCorner>
                    </example>
                </xsd:annotation>
                <ref name="cornerSetting"/>
            </element>
            <element name="highFreqCorner">
                <xsd:annotation>
                    <example>
                        <highFreqCorner>
                            <value>5</value>
                            <unit>HERTZ</unit>
                        </highFreqCorner>
                    </example>
                </xsd:annotation>
                <ref name="cornerSetting"/>
            </element>
            <element name="numPoles">
                <data type="integer">
                    <xsd:annotation>
                        <example>2</example>
                    </xsd:annotation>
                </data>
            </element>
            <element name="filterType">
                <choice>
                    <value>NONCAUSAL</value>
                    <value>CAUSAL</value>
                    <value>TWOPASS</value>
                </choice>
            </element>
        </element>
    </define>
    <define name="cornerSetting">
        <choice>
            <xsd:annotation>
                <summary>Set corners of a filter</summary>
            </xsd:annotation>
            <ref name="time"/>
            <ref name="freq"/>
        </choice>
    </define>
    <define name="rMean">
        <element name="rMean">
            <xsd:annotation>
                <summary>Remove the mean</summary>
                <description>Removes the mean of the seismograms.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="rTrend">
        <element name="rTrend">
            <xsd:annotation>
                <summary>Remove the trend</summary>
                <description>Removes the trend of the seismograms.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="taper">
        <element name="taper">
            <xsd:annotation>
                <summary>Apply a taper</summary>
                <description>Applies a taper to the seismograms. The type can be one of HANNING,
                    HAMMING or COSINE, with HANNING the default. The width is given as a fraction of
                    the seismogram length, and so should be 0.5 as otherwise the begin and end taper
                    will overlap each other. 0.05 is the default.</description>
                <example>
                    <taper>
                        <width>.05</width>
                        <type>HANNING</type>
                    </taper>
                </example>
            </xsd:annotation>
            <optional>
                <element name="width">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="type">
                    <choice>
                        <value>HANNING</value>
                        <value>HAMMING</value>
                        <value>COSINE</value>
                    </choice>
                </element>
            </optional>
        </element>
    </define>
    <define name="responseGain">
        <element name="responseGain">
            <xsd:annotation>
                <summary>Response Gain Correction</summary>
                <description>Applies a overall sensitivity from the response to the seismograms.
                    This will convert int or short seismograms into floats to avoid rounding errors
                    that could result in the output seismograms being all zeros. There is no
                    configuration.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="sacWriter">
        <element name="sacWriter">
            <xsd:annotation>
                <summary>Writes sac files from seismograms</summary>
                <description>The seismograms are written to sac files in the location indicated by location. 
                If multiple seismograms are found for a channel seismograms past the first will be written out with a number appended to their file name.  ie the second seismogram will be filename.1 and the third will be filename.2</description>
                <example>
                    <sacWriter>
                        <workingDir>seismograms</workingDir>
                        <location>${network.code}.${station.code}/${event.filizedTime}/${site.code}.${channel.code}.sac</location>
                        <phaseTimeHeader>
                            <model>prem</model>
                            <phase>ttp</phase>
                            <tHeader>0</tHeader>
                        </phaseTimeHeader>
                        <phaseTimeHeader>
                            <model>prem</model>
                            <phase>tts</phase>
                            <tHeader>1</tHeader>
                        </phaseTimeHeader>
                    </sacWriter>
                </example>
            </xsd:annotation>
            <ref name="seisWriterBase"/>
            <zeroOrMore>
                <element name="phaseTimeHeader">
                    <ref name="phaseTimeContents"/>
                </element>
            </zeroOrMore>
        </element>
    </define>
    <define name="mseedWriter">
        <element name="mseedWriter">
            <xsd:annotation>
                <summary>Writes mseed files from seismograms</summary>
                <description>The seismograms are written to mseed files in the location indicated by location. 
                    If multiple seismograms are found for a channel seismograms past the first will be written out with a number appended to their file name.  ie the second seismogram will be filename.1 and the third will be filename.2</description>
                <example>
                    <mseedWriter>
                        <workingDir>seismograms</workingDir>
                        <location>${channel.code}/${event.filizedTime}/${network.code}.${station.code}.${site.code}.mseed</location>
                        </mseedWriter>
                </example>
            </xsd:annotation>
            <ref name="seisWriterBase"/>
        </element>
    </define>
    <define name="seisWriterBase">
        <optional>
            <ref name="workingDir"/>
        </optional>
        <optional>
            <ref name="seisFileLocation"/>
        </optional>
        <optional>
            <ref name="writerName"/>
        </optional>
    </define>
    <define name="workingDir">
        <element name="workingDir">
            <xsd:annotation>
                <summary>The base directory for seismogram output</summary>
                <description>The value generated by location is appened to the value in workingDir to make the 
                location to write seismogram files.  This defaults to 'seismograms'.</description>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="writerName">
        <element name="name">
            <xsd:annotation>
                <summary>The name of this writer for reference by other processors</summary>
                <description>This only matters to other processors that wish to access the files written by this writer.
                Things like legacyExecute and sacExecute use the name to find which seismogram writer's seismograms to pass to their command.  
                If there is only one sacWriter or mseedWriter, you can just leave this alone.</description>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="seisFileLocation">
        <element name="location">
            <xsd:annotation>
                <summary>Generates file locations for seismograms</summary>
                <description>This is a
                    <a href="../../templates.html">Velocity template</a> to
                    determine the file name for the seismograms.  The template contains a list of <a href="../../templateTypes.html#seismogram">seismogram</a> named seismograms containing all the retrieved seismograms,
                    a list of <a href="../../templateTypes.html#request">request</a> named originalRequests that are the requests generated by your request generator,
                    anoter list of <a href="../../templateTypes.html#request">request</a> named availableRequests that are the requests the server said were available for retrieval, 
                                        <a href="../../templateTypes.html#site">site</a>, <a href="../../templateTypes.html#station">station</a>
                    and <a href="../../templateTypes.html#net">net</a> variables.
                    If no template element is given, it defaults to "Event_${event.getTime('yyyy_MM_dd_HH_mm_SS')}/${channel.codes}.mseed".
                   The value generated with location is appended to the value in workingDir to make the full location.
                    </description>
                <example>
                        <location>${channel.code}/${event.getTime("yyyy_DDD_HH_mm_ss")}/${network.code}.${station.code}.${site.code}.mseed</location>
                </example>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="phaseTimeContents">
        
        <element name="model">
            <data type="string"/>
        </element>
        <element name="phaseName">
            <data type="string"/>
        </element>
        <element name="tHeader">
            <data type="integer"/>
        </element>
    </define>
    <define name="saveSeismogramToFile">
        <element name="saveSeismogramToFile">
            <xsd:annotation>
                <summary>Deprecated!  Use sacWriter or mseedWriter instead!</summary>
                <description>As of sod-2.1.2 this processor is deprecated.  Unless you specifically want DSML files, use sacWriter or mseedWriter instead.  When sod-2.2 is released, this processor will no longer be allowed.
                
                 The seismograms are written to data files in the given directory. Also
                    writes out a dsml file for use in GEE and other fissures tools that support
                    datasets. If fileType isn't set, seismograms will be saved as mseed.  Always returns true unless there is an error.</description>
                <example>
                    <saveSeismogramToFile>
                        <fileType>sac</fileType>
                        <dataDirectory>POND_II</dataDirectory>
                        <eventDirLabel>Event_$event.getTime(&apos;yyyy_DDD_HH_mm_ss&apos;)</eventDirLabel>
                    </saveSeismogramToFile>
                </example>
            </xsd:annotation>
            <optional>
                <element name="fileType">
                    <choice>
                        <value>sac</value>
                        <value>mseed</value>
                    </choice>
                </element>
            </optional>
            <optional>
                <element name="prefix">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="dataDirectory">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="eventDirLabel">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="id">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="preserveRequest">
                    <empty/>
                </element>
            </optional>
            <optional>
                <element name="storeSeismogramsInDB">
                    <empty/>
                </element>
            </optional>
            <optional>
                <element name="sacHeader">
                    <zeroOrMore>
                        <element name="phaseTime">
                            <ref name="phaseTimeContents"/>
                        </element>
                    </zeroOrMore>
                </element>
            </optional>
        </element>
    </define>
    <define name="recordSectionDisplayGenerator">
        <element name="recordSectionDisplayGenerator">
            <xsd:annotation>
                <summary>Generates the recordsection display for each event</summary>
                <description>Reads the dsml file created by the saveSeismogramToFile processor and
                    generates the recordsection image file</description>
                <example>
                    <recordSectionDisplayGenerator>
                        <id>RecordSection_</id>
                        <fileNameBase>recordSection</fileNameBase>
                        <idealNumberOfSeismograms>10</idealNumberOfSeismograms>
                        <distanceRange>
                            <min>0</min>
                            <max>180</max>
                        </distanceRange>
                        <recordSectionSize>
                            <width>400</width>
                            <height>400</height>
                        </recordSectionSize>
                    </recordSectionDisplayGenerator>
                </example>
            </xsd:annotation>
            <element name="id">
                <data type="string"/>
            </element>
            <optional>
                <element name="saveSeisId">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="fileNameBase">
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="idealNumberOfSeismograms">
                    <xsd:annotation>
                        <description>specifies the ideal number of seismograms to include in this
                            record section. If possible, this many evenly spaced seismograms will be
                            included</description>
                    </xsd:annotation>
                    <data type="integer"/>
                </element>
            </optional>
            <optional>
                <element name="maxNumberOfSeismograms">
                    <xsd:annotation>
                        <description>specifies the maximum number of seismograms to include in this
                            record section. If the spacing of the ideal number is less than
                            satisfactory, this many seismograms may be included</description>
                    </xsd:annotation>
                    <data type="integer"/>
                </element>
            </optional>
            <optional>
                <element name="distanceRange">
                    <ref name="degreeRange"/>
                </element>
            </optional>
            <optional>
                <element name="percentSeisHeight">
                    <xsd:annotation>
                        <description>Height of the seismogram as a percentage of recordsection
                            height</description>
                    </xsd:annotation>
                    <data type="double"/>
                </element>
            </optional>
            <optional>
                <ref name="recordSectionSize"/>
            </optional>
            <optional>
                <element name="displayConfig">
                    <ref name="recordSectionDisplayContents"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="recordSectionSize">
        <element name="recordSectionSize">
            <xsd:annotation>
                <summary>Specifies the size of the recordsection</summary>
                <description>Specifies the size of the recordsection</description>
                <example>
                    <recordSectionSize>
                        <width>500</width>
                        <height>500</height>
                    </recordSectionSize>
                </example>
            </xsd:annotation>
            <element name="width">
                <data type="integer"/>
            </element>
            <element name="height">
                <data type="integer"/>
            </element>
        </element>
    </define>
    <define name="externalWaveformProcess">
        <element name="externalWaveformProcess">
            <xsd:annotation>
                <summary>Runs an externally defined Java processor</summary>
                <description>This runs the Java processor defined in the given class, which must
                    implement the edu.sc.seis.sod.process.waveformArm.process.WaveformProcess
                    interface.</description>
                <example>
                    <externalWaveformProcess>
                        <classname>edu.myuniv.seis.xyz.MySeisProcessor</classname>
                        <dataDirectory>POND_II</dataDirectory>
                        <extraParam>1.7</extraParam>
                    </externalWaveformProcess>
                </example>
            </xsd:annotation>
            <element name="classname">
                <data type="string"/>
            </element>
            <zeroOrMore>
                <externalRef href="../base/externalRef/anyXML.rng"/>
            </zeroOrMore>
        </element>
    </define>
    <define name="printlineSeismogramProcess">
        <element name="printlineSeismogramProcess">
            <xsd:annotation>
                <summary>Prints a line to std out for each seismogram processed</summary>
                <description>This simply prints a line to standard out or a file for each seismogram to be
                    processed. It can be used as a simple status monitor.  Both filename and template are 
                    <a href="../../templates.html">Velocity templates</a>.  
                    They contain a list of <a href="../../templateTypes.html#seismogram">seismogram</a> named seismograms containing all the retrieved seismograms,
                    a list of <a href="../../templateTypes.html#request">request</a> named originalRequests that are the requests generated by your request generator,
                    anoter list of <a href="../../templateTypes.html#request">request</a> named availableRequests that are the requests the server said were available for retrieval, 
                    <a href="../../templateTypes.html#site">site</a>, <a href="../../templateTypes.html#station">station</a>,
                    <a href="../../templateTypes.html#net">net</a> and 
                    <a href="../../templateTypes.html#event">event</a> variables.
                    If no template element is given, it defaults to "Got $seismograms.size() seismograms for $channel.codes for eq on $event.time".
                    If no filename is given, the output goes to standard out.</description>
                <include/>
            </xsd:annotation>
            <optional>
                <element name="template">
                    <text/>
                </element>
            </optional>
            <optional>
                <element name="filename">
                    <text/>
                </element>
            </optional>
        </element>
    </define>
    <define name="localSeismogramStatus">
        <element name="localSeismogramTemplateGenerator">
            <xsd:annotation>
                <summary>Generate HTML status pages about the processed seismograms</summary>
            </xsd:annotation>
            <element name="template">
                <data type="string">
                    <xsd:annotation>
                        <example>jar:edu/sc/seis/sod/data/templates/waveformArm/localSeismogram.xml</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="forkProcess">
        <element name="forkProcess">
            <xsd:annotation>
                <summary>Forks the processing of seismograms</summary>
                <description>This forks the processing of the seismograms so that more than one
                    sequence of processing steps can be applied to the data independently. If
                    another processor follows the fork it gets the seismograms as they went into the
                    fork, but only executes if the items in the fork passed. If you want to execute
                    the items past the fork no matter what, enclose it in an alwaysSuccess tag.</description>
                <example>
                    <forkProcess>
                        <rTrend/>
                        <saveSeismogramToFile>
                            <fileType>sac</fileType>
                            <dataDirectory>rTrendData</dataDirectory>
                            <eventDirLabel> Event_<originTime>yyyy_DDD_HH_mm_ss</originTime>
                            </eventDirLabel>
                        </saveSeismogramToFile>
                    </forkProcess>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="seismogramProcess"/>
            </oneOrMore>
        </element>
    </define>
    <define name="alwaysSuccess">
        <element name="alwaysSuccess">
            <xsd:annotation>
                <summary>Executes a subprocessor, but always returns true</summary>
                <description>This executes the enclosed processor, but always returns a success
                    regardless of whether the enclosed processor succeeded or failed.</description>
                <example>
                    <alwaysSuccess>
                        <printlineSeismogramProcess/>
                    </alwaysSuccess>
                </example>
            </xsd:annotation>
            <ref name="seismogramProcess"/>
        </element>
    </define>
    <define name="phaseSignalToNoise">
        <element name="phaseSignalToNoise">
            <xsd:annotation>
                <summary>Accepts or rejects seismograms based on their signal to noise ratio</summary>
                <description>This calculates the signal to noise ratio in the time window described
                    by the offsets around the given phases and passes if the ratio is less than the
                    given ratio. See the documentation for the TauP Toolkit, http://www.seis.sc.edu/TauP for the phase naming
                    convention. SOD uses the TauP Toolkit internally.</description>
                <example>
                    <phaseSignalToNoise>
                        <phaseName>ttp</phaseName>
                        <shortOffsetBegin>
                            <unit>SECOND</unit>
                            <value>-5</value>
                        </shortOffsetBegin>
                        <shortOffsetEnd>
                            <unit>SECOND</unit>
                            <value>5</value>
                        </shortOffsetEnd>
                        <longOffsetBegin>
                            <unit>SECOND</unit>
                            <value>-105</value>
                        </longOffsetBegin>
                        <longOffsetEnd>
                            <unit>SECOND</unit>
                            <value>-5</value>
                        </longOffsetEnd>
                        <ratio>2.5</ratio>
                    </phaseSignalToNoise>
                </example>
            </xsd:annotation>
            <optional>
                <element name="modelName">
                    <data type="string"/>
                </element>
            </optional>
            <element name="phaseName">
                <data type="string"/>
            </element>
            <element name="shortOffsetBegin">
                <ref name="time"/>
            </element>
            <element name="shortOffsetEnd">
                <ref name="time"/>
            </element>
            <element name="longOffsetBegin">
                <ref name="time"/>
            </element>
            <element name="longOffsetEnd">
                <ref name="time"/>
            </element>
            <element name="ratio">
                <data type="float"/>
            </element>
        </element>
    </define>
    <define name="seismogramImageProcess">
        <element name="seismogramImageProcess">
            <xsd:annotation>
                <summary>Make images of the processed seismograms</summary>
            </xsd:annotation>
            <ref name="seismogramImageBase"/>
            <optional>
                <element name="displayConfig">
                    <ref name="basicSeismogramDisplayContents"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="legacyExecute">
        <element name="legacyExecute">
            <xsd:annotation>
                <summary>Executes an external program.</summary>
                <description>The legacyExecute processor is capable of running existing command line
                    programs. It does this by passing the filename of the seismograms saved by a
                    earlier sacWriter or mseedWriter processor to a program started with Runtime.exec(). </description>
                <example>
                    <legacyExecute>
                        <command>echo</command>
                    </legacyExecute>
                </example>
            </xsd:annotation>
            <optional>
                <element name="writerName">
                    <xsd:annotation>
                    <summary>The name of the writer that wrote the seismograms</summary>
                        <description>sacWriter and mseedWriter have a name element.  The files passed to the command here are the ones written by the sacWriter or mseedWriter with this name.  Defaults to no name</description>
                    </xsd:annotation>
                    <data type="string"/>
                </element>
            </optional>
            <element name="command">
                <data type="string"/>
            </element>
            <optional>
                <element name="workingDirectory">
                    <data type="string"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="noDataGaps">
        <element name="noDataGaps">
            <xsd:annotation>
                <summary>Only allows seismograms with gapless data through</summary>
                <description>This processor checks the data returned from the dataCenter for gaps
                    larger than the sample period of the instrument. If from the begin time of the
                    earliest piece to the end time of the latest piece there are no gaps in time
                    larger than the sample period, this process passes the data onto the next item
                    in the line.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="someDataCoverage">
        <element name="someDataCoverage">
            <xsd:annotation>
                <summary>Only allows seismograms with data overlapping the original request through</summary>
                <description>This processor checks the data returned from the dataCenter against the
                    request generated by the request generator. If at least one piece of data exists
                    during the time specified by the request generator, this processor passes the
                    data onto the next step.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="fullDataCoverage">
        <element name="fullDataCoverage">
            <xsd:annotation>
                <summary>Only allows seismograms with data covering the entire original request
                    through</summary>
                <description>This processor checks the data returned from the dataCenter for
                    complete coverage of the original request. If from the begin time of the
                    earliest piece is before the start of the request, and the end time of the
                    latest piece is past the end of the request, the data passes. This does not
                    guarantee that there are no gaps in the middle of the request though. To ensure
                    that, combine this processor with a noDataGaps processor in a
                seismogramAND.</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="integrate">
        <element name="integrate">
            <xsd:annotation>
                <summary>Integrates the seismograms, changing velocity to displacement for example.</summary>
                <description>This processor integrates each seismogram, using a integration constant
                    of zero. This can be used to change velocity to displacement. </description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="embeddedEventChannelProcessor">
        <element name="embeddedEventChannelProcessor">
            <xsd:annotation>
                <summary>Allows any event channel subsetter to be embedded here</summary>
            </xsd:annotation>
            <externalRef href="eventChannel.rng"/>
        </element>
    </define>
    <define name="transferResponse">
        <element name="transferResponse">
            <xsd:annotation>
                <summary>Applies an instrumentation correction as in the transfer command in SAC</summary>
                <description>This calculates and applies the polezero response from the sensor
                    (stage 1) in the response along with the overall gain. Great care should be
                    taken with this processor as the transfer is a spectral division, and is hence
                    inherently unstable. This basically means that if you allow the frequency limits
                    to be too large, specified in lowCut, lowPass, highPass and highCut, you will be
                    dividing one very small number by another very small number, which due to
                    rounding errors may generate very large amplitudes at long periods which are not
                    real. Also, you should almost always apply an rmean and taper before applying
                    transferResponse. See the sac manual for more discussion of transfer. </description>
                <example>
                    <transferResponse>
                        <lowCut>0.005</lowCut>
                        <lowPass>0.01</lowPass>
                        <highPass>1e5</highPass>
                        <highCut>1e6</highCut>
                    </transferResponse>
                </example>
            </xsd:annotation>
            <optional>
                <element name="lowCut">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="lowPass">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="highPass">
                    <data type="float"/>
                </element>
            </optional>
            <optional>
                <element name="highCut">
                    <data type="float"/>
                </element>
            </optional>
        </element>
    </define>
    <define name="retryAndContinue">
        <element name="retryAndContinue">
            <ref name="seismogramProcess"/>
        </element>
    </define>
    <define name="retryAndFail">
        <element name="retryAndFail">
            <ref name="seismogramProcess"/>
        </element>
    </define>
</grammar>
