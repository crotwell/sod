<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
    xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <include href="../base/include/externalClass.rng"/>
    <include href="../base/include/quantity.rng"/>
    <start>
        <ref name="availableData"/>
    </start>
    <include href="../base/include/eventLabel.rng"/>
    <define name="availableData">
        <choice>
            <xsd:annotation>
                <summary>Tactics for subsetting based on the availability of data</summary>
                <description>Before SOD asks the data center to send it data, it asks the data
                    center if it has data for the time range generated by the request generator.
                    These tactics allow decisions to be made based on the server's response.</description>
            </xsd:annotation>
            <ref name="fullCoverage"/>
            <ref name="postEventWait"/>
            <ref name="noGaps"/>
            <ref name="someCoverage"/>
            <ref name="availableDataAND"/>
            <ref name="availableDataOR"/>
            <ref name="availableDataNOT"/>
            <ref name="PASS"/>
            <ref name="externalAvailable"/>
        </choice>
    </define>
    <define name="availableDataAND">
        <element name="availableDataAND">
            <xsd:annotation>
                <summary>Matches all enclosed AvailableData subsetters</summary>
                <description>The output is the logical AND of the outputs of all included
                    AvailableData subsetters. This means that it will evaluate to true only if all
                    the enclosed AvailableData subsetters evaluate to true. The subsetters after the
                    first false outputted are not evaluated.</description>
                <example>
                    <availableDataAND>
                        <noGaps/>
                        <fullCoverage/>
                    </availableDataAND>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="availableData"/>
            </oneOrMore>
        </element>
    </define>
    <define name="availableDataOR">
        <element name="availableDataOR">
            <xsd:annotation>
                <summary>Matches at least one enclosed AvailableData subsetter</summary>
                <description>The output is the logical OR of the outputs of all included
                    AvailableData subsetters. This means that it will evaluate to true if at least
                    one of the enclosed AvailableData subsetters evaluate to true. The subsetters
                    after the first true outputted are not evaluated.</description>
                <example>
                    <availableDataOR>
                        <noGaps/>
                        <fullCoverage/>
                    </availableDataOR>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="availableData"/>
            </oneOrMore>
        </element>
    </define>
    <define name="availableDataNOT">
        <element name="availableDataNOT">
            <xsd:annotation>
                <summary>Matches the negated output of the enclosed AvailableData subsetter</summary>
                <description>The output is the logical NOT of the output of the enclosed
                    AvailableData subsetter. This means that it will evaluate to false if the
                    enclosed AvailableData subsetter evaluates to true, and vice versa.</description>
                <example>
                    <availableDataNOT>
                        <noGaps/>
                    </availableDataNOT>
                </example>
            </xsd:annotation>
            <ref name="availableData"/>
        </element>
    </define>
    <define name="noGaps">
        <element name="noGaps">
            <xsd:annotation>
                <summary>Accepts data only if it has no gaps</summary>
                <description>If the server says the data it has is continuous, this tactic passes</description>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="fullCoverage">
        <element name="fullCoverage">
            <xsd:annotation>
                <summary>Accepts data only if it spans the entire generated request</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="someCoverage">
        <element name="someCoverage">
            <xsd:annotation>
                <summary>Accepts data if it spans some of the generated request</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="postEventWait">
        <element name="postEventWait">
            <xsd:annotation>
                <summary>Ensure good data after a fresh event</summary>
                <description>When running SOD in realtime mode, this tells it how long to wait after
                    a fresh event before trying to get data. This allows for data that isn't
                    immediately available to be submitted to the seismogram servers. For more
                    information look at the <a href="../../../realtime.html">Realtime Run
                    Considerations</a> for more details on how to use this subsetter in conjunction
                    with the other availableData subsetters.</description>
            </xsd:annotation>
            <ref name="time"/>
        </element>
    </define>
    <define name="PASS">
        <element name="passAvailableData">
            <xsd:annotation>
                <summary>Accepts any available data</summary>
                <description>This is a simple subsetter that always returns true for any available
                    data, which is useful for testing purposes.</description>
                <example>
                    <passAvailableData/>
                </example>
            </xsd:annotation>
            <zeroOrMore>
                <ref name="availableData"/>
            </zeroOrMore>
        </element>
    </define>
    <define name="externalAvailable">
        <element name="externalAvailableDataSubsetter">
            <xsd:annotation>
                <summary>Use an AvailableData subsetter external to SOD</summary>
                <description>Attempts to load the class named by classname, and if it implements
                    AvailableDataSubsetter, SOD calls accept() on the class for every event,
                    channel, and their available data.</description>
                <example>
                    <externalAvailableDataSubsetter>
                        <classname>edu.somewhere.seis.sodExt.subsetter.availableData.MyAvailableDataSubsetter</classname>
                    </externalAvailableDataSubsetter>
                </example>
            </xsd:annotation>
            <ref name="externalClass"/>
        </element>
    </define>
</grammar>
