<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
    xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <include href="../base/include/externalClass.rng"/>
    <start>
        <ref name="station"/>
    </start>
    <include href="../base/include/timeRange.rng"/>
    <include href="../base/include/range.rng"/>
    <include href="../base/include/latLon.rng"/>
    <define name="station">
        <choice>
            <xsd:annotation>
                <summary>Tactics for selecting stations</summary>
                <description>This collects all of the subsetters that make decisions on the contents
                    of a station.</description>
            </xsd:annotation>
            <ref name="code"/>
            <ref name="regExp"/>
            <ref name="name"/>
            <ref name="operator"/>
            <ref name="depthRange"/>
            <ref name="effectiveTimeOverlap"/>
            <ref name="area"/>
            <ref name="stationPointDistance"/>
            <ref name="stationPointAzimuth"/>
            <ref name="stationPointBackAzimuth"/>
            <ref name="AND"/>
            <ref name="OR"/>
            <ref name="NOT"/>
            <ref name="PASS"/>
            <ref name="externalStationSubsetter"/>
        </choice>
    </define>
    <define name="stationLogical">
        <choice>
            <ref name="code"/>
            <ref name="regExp"/>
            <ref name="name"/>
            <ref name="operator"/>
            <ref name="depthRange"/>
            <ref name="effectiveTimeOverlap"/>
            <ref name="area"/>
            <ref name="stationPointDistance"/>
            <ref name="stationPointAzimuth"/>
            <ref name="stationPointBackAzimuth"/>
            <ref name="AND"/>
            <ref name="OR"/>
            <ref name="NOT"/>
            <ref name="PASS"/>
            <ref name="externalStationSubsetter"/>
            <externalRef href="network.rng"/>
        </choice>
    </define>
    <define name="code">
        <element name="stationCode">
            <xsd:annotation>
                <summary>Matches a station code</summary>
                <description>Matches a station code. This is a simple string match.</description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>ANMO</example>
                </xsd:annotation>
            </data>
        </element>
    </define>
    <define name="regExp">
        <element name="stationRegularExpression">
            <xsd:annotation>
                <summary>Matches a station if it's network code and station code match a regular
                    expression</summary>
            </xsd:annotation>
            <element name="url">
                <data type="string">
                    <xsd:annotation>
                        <example>http://seis.sc.edu/GEE/Dynamic/GEE_2.1/configs/filterStations.txt</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="name">
        <element name="stationName">
            <xsd:annotation>
                <summary>Matches the name of a station</summary>
                <description> Matches the name of a station. This is a simple string comparison, and
                    so care must be taken for this to be useful. </description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>South Karori, New Zealand</example>
                </xsd:annotation>
            </data>
        </element>
    </define>
    <define name="operator">
        <element name="stationOperator">
            <xsd:annotation>
                <summary>Matches the operator of a station</summary>
                <description> Matches the operator of a station. This is a simple string comparison,
                    and so care must be taken for this to be useful. </description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>Joe Seismologist</example>
                </xsd:annotation>
            </data>
        </element>
    </define>
    <define name="depthRange">
        <element name="stationDepthRange">
            <xsd:annotation>
                <summary>Matches stations at a range of depths below the surface</summary>
                <description> Matches stations at a range of depths below the surface. </description>
                <example>
                    <stationDepthRange>
                        <unit>METER</unit>
                        <min>100</min>
                        <max>200</max>
                    </stationDepthRange>
                </example>
            </xsd:annotation>
            <ref name="range"/>
        </element>
    </define>
    <define name="effectiveTimeOverlap">
        <element name="stationEffectiveTimeOverlap">
            <xsd:annotation>
                <summary>Matches if the station effective time overlaps the given time range</summary>
                <description> Matches if the station effective time overlaps the given time range.
                    This is generally used to avoid processing stations that did not yet exist, or
                    were deactivated before a time range of interest. </description>
            </xsd:annotation>
            <ref name="timeRange"/>
        </element>
    </define>
    <define name="area">
        <element name="stationArea">
            <xsd:annotation>
                <summary>Matches stations that are within a given area</summary>
            </xsd:annotation>
            <externalRef href="../base/externalRef/area.rng"/>
        </element>
    </define>
    <define name="stationPointDistance">
        <element name="stationPointDistance">
            <xsd:annotation>
                <summary> Distance range from a fixed point</summary>
                <description> True if the station is within the given distance range of the given
                    lat and lon. </description>
            </xsd:annotation>
            <ref name="range"/>
            <ref name="lat"/>
            <ref name="lon"/>
        </element>
    </define>
    <define name="stationPointAzimuth">
        <element name="stationPointAzimuth">
            <xsd:annotation>
                <summary>Azimuth (point to station) range from a fixed point</summary>
                <description> True if the station is within the given azimuth range of the given lat
                    and lon. In keeping with common seismic terminology, azimuth is measured from
                    the point to the station.</description>
            </xsd:annotation>
            <ref name="range"/>
            <ref name="lat"/>
            <ref name="lon"/>
        </element>
    </define>
    <define name="stationPointBackAzimuth">
        <element name="stationPointBackAzimuth">
            <xsd:annotation>
                <summary>Back azimuth (station to point) range from a fixed point</summary>
                <description> True if the station is within the given back azimuth range of the
                    given lat and lon. In keeping with common seismic terminology, back azimuth is
                    measured from the station to the point. </description>
            </xsd:annotation>
            <ref name="range"/>
            <ref name="lat"/>
            <ref name="lon"/>
        </element>
    </define>
    <define name="AND">
        <element name="stationAND">
            <xsd:annotation>
                <summary>Matches all enclosed Station subsetters</summary>
                <description>The output is the logical AND of the outputs of all included Station
                    subsetters. This means that it will evaluate to true only if all the enclosed
                    Station subsetters evaluate to true. The subsetters after the first false
                    outputted are not evaluated.</description>
                <example>
                    <stationAND>
                        <stationEffectiveTimeOverlap>
                            <startTime>20020701T00:00:00.001Z</startTime>
                            <endTime>20021030T00:00:00.001Z</endTime>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationAND>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="stationLogical"/>
            </oneOrMore>
        </element>
    </define>
    <define name="OR">
        <element name="stationOR">
            <xsd:annotation>
                <summary>Matches at least one enclosed Station subsetter</summary>
                <description>The output is the logical OR of the outputs of all included Station
                    subsetters. This means that it will evaluate to true if at least one of the
                    enclosed Station subsetters evaluate to true. The subsetters after the first
                    true outputted are not evaluated.</description>
                <example>
                    <stationOR>
                        <stationEffectiveTimeOverlap>
                            <startTime>20020701T00:00:00.001Z</startTime>
                            <endTime>20021030T00:00:00.001Z</endTime>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationOR>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="stationLogical"/>
            </oneOrMore>
        </element>
    </define>
    <define name="NOT">
        <element name="stationNOT">
            <xsd:annotation>
                <summary>Matches the negated output of the enclosed Station subsetter</summary>
                <description>CHANGE The output is the logical NOT of the output of the enclosed
                    Station subsetter. This means that it will evaluate to false if the enclosed
                    Station subsetter evaluates to true, and vice versa.</description>
            </xsd:annotation>
            <ref name="station"/>
        </element>
    </define>
    <define name="PASS">
        <element name="passStation">
            <xsd:annotation>
                <summary>Accepts any station</summary>
                <description>This is a simple subsetter that always returns true for any Station,
                    which is useful for testing purposes.</description>
                <example>
                    <passStation/>
                </example>
            </xsd:annotation>
            <zeroOrMore>
                <ref name="station"/>
            </zeroOrMore>
        </element>
    </define>
    <define name="externalStationSubsetter">
        <element name="externalStationSubsetter">
            <xsd:annotation>
                <summary>Use a station subsetter external to SOD</summary>
                <description>Attempts to load the class named by classname, and if it implements
                    StationSubsetter, SOD calls accept() on the class for every station.</description>
                <example>
                    <externalStationSubsetter>
                        <classname>edu.somewhere.seis.sodExt.subsetter.station.MyStationSubsetter</classname>
                    </externalStationSubsetter>
                </example>
            </xsd:annotation>
            <ref name="externalClass"/>
        </element>
    </define>
</grammar>
