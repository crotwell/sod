<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
    xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <include href="../base/include/externalClass.rng"/>
    <start>
        <ref name="station"/>
    </start>
    <include href="../base/include/timeRange.rng"/>
    <include href="../base/include/range.rng"/>
    <include href="../base/include/latLon.rng"/>
    <define name="station">
        <choice>
            <xsd:annotation>
                <summary>Tactics for selecting stations</summary>
                <description>This collects all of the subsetters that make decisions on the contents
                    of a station.</description>
                <velocity>#networkArmPage()</velocity>
            </xsd:annotation>
            <ref name="code"/>
            <ref name="regExp"/>
            <ref name="name"/>
            <ref name="operator"/>
            <ref name="depthRange"/>
            <ref name="effectiveTimeOverlap"/>
            <ref name="area"/>
            <ref name="stationPointDistance"/>
            <ref name="stationPointAzimuth"/>
            <ref name="stationPointBackAzimuth"/>
            <ref name="AND"/>
            <ref name="OR"/>
            <ref name="NOT"/>
            <ref name="externalStationSubsetter"/>
            <ref name="belongsToVirtual"/>
        </choice>
    </define>
    <define name="stationLogical">
        <choice>
            <ref name="code"/>
            <ref name="regExp"/>
            <ref name="name"/>
            <ref name="operator"/>
            <ref name="depthRange"/>
            <ref name="effectiveTimeOverlap"/>
            <ref name="area"/>
            <ref name="stationPointDistance"/>
            <ref name="stationPointAzimuth"/>
            <ref name="printlineStationProcess"/>
            <ref name="stationPointBackAzimuth"/>
            <ref name="AND"/>
            <ref name="OR"/>
            <ref name="NOT"/>
            <ref name="externalStationSubsetter"/>
            <externalRef href="network.rng"/>
        </choice>
    </define>
    <define name="code">
        <element name="stationCode">
            <xsd:annotation>
                <summary>Matches a station code</summary>
                <description>Matches a station code. This is a simple string match.</description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>ANMO</example>
                </xsd:annotation>
            </data>
        </element>
    </define>
    <define name="regExp">
        <element name="stationRegularExpression">
            <xsd:annotation>
                <summary>Matches a station if it's network code and station code match a regular
                    expression</summary>
            </xsd:annotation>
            <element name="url">
                <data type="string">
                    <xsd:annotation>
                        <example>http://seis.sc.edu/GEE/Dynamic/GEE_2.1/configs/filterStations.txt</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="name">
        <element name="stationName">
            <xsd:annotation>
                <summary>Matches the name of a station</summary>
                <description> Matches the name of a station. This is a simple string comparison, and
                    so care must be taken for this to be useful. </description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>South Karori, New Zealand</example>
                </xsd:annotation>
            </data>
        </element>
    </define>
    <define name="operator">
        <element name="stationOperator">
            <xsd:annotation>
                <summary>Matches the operator of a station</summary>
                <description> Matches the operator of a station. This is a simple string comparison,
                    and so care must be taken for this to be useful. </description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>Joe Seismologist</example>
                </xsd:annotation>
            </data>
        </element>
    </define>
    <define name="depthRange">
        <element name="stationDepthRange">
            <xsd:annotation>
                <summary>Matches stations at a range of depths below the surface</summary>
                <description> Matches stations at a range of depths below the surface. </description>
                <example>
                    <stationDepthRange>
                        <unit>METER</unit>
                        <min>100</min>
                        <max>200</max>
                    </stationDepthRange>
                </example>
            </xsd:annotation>
            <ref name="range"/>
        </element>
    </define>
    <define name="effectiveTimeOverlap">
        <element name="stationEffectiveTimeOverlap">
            <xsd:annotation>
                <summary>Matches if the station effective time overlaps the given time range</summary>
                <description>Matches if the station effective time overlaps the given time range.
                    This is generally used to avoid processing stations that did not yet exist, or
                    were deactivated before a time range of interest.  By default, SOD uses a stationEffectiveTimeOverlap configured with the event arm's time range.  
                    If all you want to do is make sure your stations are active during 
                    your events, that's already done.</description>
            </xsd:annotation>
            <ref name="timeRange"/>
        </element>
    </define>
    <define name="area">
        <element name="stationArea">
            <xsd:annotation>
                <summary>Matches stations that are within a given area</summary>
            </xsd:annotation>
            <externalRef href="../base/externalRef/area.rng"/>
        </element>
    </define>
    <define name="stationPointDistance">
        <element name="stationPointDistance">
            <xsd:annotation>
                <summary> Distance range from a fixed point</summary>
                <description> True if the station is within the given distance range of the given
                    lat and lon. </description>
            </xsd:annotation>
            <externalRef href="../base/externalRef/latLonUnitRange.rng"/>
        </element>
    </define>
    <define name="stationPointAzimuth">
        <element name="stationPointAzimuth">
            <xsd:annotation>
                <summary>Azimuth (point to station) range from a fixed point</summary>
                <description> True if the station is within the given azimuth range of the given lat
                    and lon. In keeping with common seismic terminology, azimuth is measured from
                    the point to the station.</description>
            </xsd:annotation>
            <externalRef href="../base/externalRef/latLonUnitRange.rng"/>
        </element>
    </define>
    <define name="stationPointBackAzimuth">
        <element name="stationPointBackAzimuth">
            <xsd:annotation>
                <summary>Back azimuth (station to point) range from a fixed point</summary>
                <description> True if the station is within the given back azimuth range of the
                    given lat and lon. In keeping with common seismic terminology, back azimuth is
                    measured from the station to the point. </description>
            </xsd:annotation>
            <externalRef href="../base/externalRef/latLonUnitRange.rng"/>
        </element>
    </define>
    <define name="AND">
        <element name="stationAND">
            <xsd:annotation>
                <summary>Matches all enclosed Station subsetters</summary>
                <description>The output is the logical AND of the outputs of all included Station
                    subsetters. This means that it will evaluate to true only if all the enclosed
                    Station subsetters evaluate to true. The subsetters after the first false
                    outputted are not evaluated.</description>
                <example>
                    <stationAND>
                        <stationEffectiveTimeOverlap>
                            <startTime>20020701T00:00:00.001Z</startTime>
                            <endTime>20021030T00:00:00.001Z</endTime>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationAND>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="stationLogical"/>
            </oneOrMore>
        </element>
    </define>
    <define name="OR">
        <element name="stationOR">
            <xsd:annotation>
                <summary>Matches at least one enclosed Station subsetter</summary>
                <description>The output is the logical OR of the outputs of all included Station
                    subsetters. This means that it will evaluate to true if at least one of the
                    enclosed Station subsetters evaluate to true. The subsetters after the first
                    true outputted are not evaluated.</description>
                <example>
                    <stationOR>
                        <stationEffectiveTimeOverlap>
                            <startTime>20020701T00:00:00.001Z</startTime>
                            <endTime>20021030T00:00:00.001Z</endTime>
                        </stationEffectiveTimeOverlap>
                        <stationArea>
                            <boxArea>
                                <latitudeRange>
                                    <min>25</min>
                                    <max>35</max>
                                </latitudeRange>
                                <longitudeRange>
                                    <min>-80</min>
                                    <max>-70</max>
                                </longitudeRange>
                            </boxArea>
                        </stationArea>
                    </stationOR>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="stationLogical"/>
            </oneOrMore>
        </element>
    </define>
    <define name="NOT">
        <element name="stationNOT">
            <xsd:annotation>
                <summary>Matches the negated output of the enclosed Station subsetter</summary>
                <description>CHANGE The output is the logical NOT of the output of the enclosed
                    Station subsetter. This means that it will evaluate to false if the enclosed
                    Station subsetter evaluates to true, and vice versa.</description>
            </xsd:annotation>
            <ref name="station"/>
        </element>
    </define>
    <define name="externalStationSubsetter">
        <element name="externalStationSubsetter">
            <xsd:annotation>
                <summary>Use a station subsetter external to SOD</summary>
                <description>$externalStationSubsetterInfo.getRelaxHTML('../../../')</description>
                <example>
                    <externalStationSubsetter>
                        <classname>edu.somewhere.seis.sodExt.subsetter.station.MyStationSubsetter</classname>
                    </externalStationSubsetter>
                </example>
            </xsd:annotation>
            <ref name="externalClass"/>
        </element>
    </define>
    <define name="belongsToVirtual">
        <element name="belongsToVirtual">
            <xsd:annotation>
                <summary>Check if the station belongs to a particular virtual network</summary>
                <description>If the station belongs to the virtual network of the code in the element, this returns true.
                    Current virtual networks in the IRIS Network DC can be found from <a href="http://www.iris.edu/SeismiQuery/virtual_net.htm">SeismoQuery</a>.</description>
                <example>
                    <belongsToVirtual>_US-TA</belongsToVirtual>
                </example>
            </xsd:annotation>
<text/>
        </element>
    </define>
    <define name="printlineStationProcess">
        <element name="printlineStationProcess">
            <xsd:annotation>
                <summary>Prints every successful station to the console or to the specified file</summary>
                <description>Prints out each station on a new line. The template and filename elements are both <a
                        href="../../templates.html">Velocity templates</a> containing <a
                    href="../../templateTypes.html#station">station</a> and <a
                    href="../../templateTypes.html#net">net</a> variables. If no template element is given, it defaults
                    to "Station: $station". If no filename is given, the output goes to standard out.</description>
            </xsd:annotation>
            <interleave>
                <optional>
                    <element name="template">
                        <text/>
                    </element>
                </optional>
                <optional>
                    <element name="filename">
                        <text/>
                    </element>
                </optional>
            </interleave>
        </element>
    </define>
</grammar>
