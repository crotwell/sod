<?xml version="1.0" encoding="UTF-8"?>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes" xmlns="http://relaxng.org/ns/structure/1.0" xmlns:xsd="http://http://www.w3.org/2001/XMLSchema">
    <include href="../base/include/externalClass.rng"/>
    <start>
        <ref name="channel"/>
    </start>
    <include href="../base/include/timeRange.rng"/>
    <include href="../base/include/quantity.rng"/>
    <include href="../base/include/samplingRange.rng"/>
    <define name="channel">
        <choice>
            <xsd:annotation>
                <summary>Tactics for selecting channels</summary>
                <description>This collects all of the subsetters that make decisions on the contents of a channel.</description>
                <velocity>#networkArmPage()</velocity>
            </xsd:annotation>
            <ref name="hadDataLastWeek"/>
            <ref name="channelCode"/>
            <ref name="bandCode"/>
            <ref name="gainCode"/>
            <ref name="orientationCode"/>
            <ref name="sampling"/>
            <ref name="effectiveTimeOverlap"/>
            <ref name="orientationRange"/>
            <ref name="orientationAzimuthRange"/>
            <ref name="orientationDipRange"/>
            <ref name="AND"/>
            <ref name="OR"/>
            <ref name="NOT"/>
            <ref name="externalChannelSubsetter"/>
            <ref name="printline"/>
            <ref name="responseWriter"/>
            <ref name="sacPoleZeroWriter"/>
            <ref name="stationHas"/>
            <ref name="alwaysSuccess"/>
            <ref name="hasResponse"/>
            <ref name="hasSensitivity"/>
            <ref name="repairSensitivity"/>
            <ref name="clockId"/>
            <ref name="clockManufacturer"/>
            <ref name="clockModel"/>
            <ref name="clockSerial"/>
            <ref name="clockType"/>
            <ref name="dasId"/>
            <ref name="dasManufacturer"/>
            <ref name="dasModel"/>
            <ref name="dasSerial"/>
            <ref name="dasStyle"/>
            <ref name="sensorId"/>
            <ref name="sensorManufacturer"/>
            <ref name="sensorModel"/>
            <ref name="sensorSerial"/>
            <ref name="sensorNominalHighFreq"/>
            <ref name="sensorNominalLowFreq"/>
            <ref name="hasNegativeSensitivity"/>
            <ref name="isFlipped"/>
        </choice>
    </define>
    <define name="channelLogical">
        <choice>
            <ref name="channelCode"/>
            <ref name="bandCode"/>
            <ref name="gainCode"/>
            <ref name="orientationCode"/>
            <ref name="sampling"/>
            <ref name="effectiveTimeOverlap"/>
            <ref name="orientationRange"/>
            <ref name="orientationAzimuthRange"/>
            <ref name="orientationDipRange"/>
            <ref name="AND"/>
            <ref name="OR"/>
            <ref name="NOT"/>
            <ref name="externalChannelSubsetter"/>
            <externalRef href="site.rng"/>
            <externalRef href="station.rng"/>
            <externalRef href="network.rng"/>
            <ref name="hadDataLastWeek"/>
            <ref name="printline"/>
            <ref name="responseWriter"/>
            <ref name="stationHas"/>
            <ref name="alwaysSuccess"/>
            <ref name="hasResponse"/>
            <ref name="hasSensitivity"/>
            <ref name="repairSensitivity"/>
            <ref name="clockId"/>
            <ref name="clockManufacturer"/>
            <ref name="clockModel"/>
            <ref name="clockSerial"/>
            <ref name="clockType"/>
            <ref name="dasId"/>
            <ref name="dasManufacturer"/>
            <ref name="dasModel"/>
            <ref name="dasSerial"/>
            <ref name="dasStyle"/>
            <ref name="sensorId"/>
            <ref name="sensorManufacturer"/>
            <ref name="sensorModel"/>
            <ref name="sensorSerial"/>
            <ref name="sensorNominalHighFreq"/>
            <ref name="sensorNominalLowFreq"/>
            <ref name="hasNegativeSensitivity"/>
            <ref name="isFlipped"/>
        </choice>
    </define>
    <define name="singleLetterOrNumber">
        <data type="string">
            <xsd:annotation>
                <summary>Matches a single letter or number</summary>
                <example>B</example>
            </xsd:annotation>
            <param name="pattern">[A-Z0-9]{1}</param>
        </data>
    </define>
    <define name="channelCode">
        <element name="channelCode">
            <xsd:annotation>
                <summary>Matches the entire channel code</summary>
                <description>Matches a channel code, such as BHZ. See the <a
                        href="http://www.iris.edu/manuals/SEED_appA.htm">SEED manual</a> for the list of available code letters.</description>
            </xsd:annotation>
            <data type="string">
                <xsd:annotation>
                    <example>BHZ</example>
                </xsd:annotation>
                <param name="pattern">[A-Z0-9]{3}</param>
            </data>
        </element>
    </define>
    <define name="bandCode">
        <element name="bandCode">
            <xsd:annotation>
                <summary>Matches the band code of a channel</summary>
                <description>Matches the band code of a channel, such as B for broadband and L for long period. See the
                        <a href="http://www.iris.edu/manuals/SEED_appA.htm">SEED manual</a> for the list of available
                    code letters.</description>
            </xsd:annotation>
            <ref name="singleLetterOrNumber"/>
        </element>
    </define>
    <define name="gainCode">
        <element name="gainCode">
            <xsd:annotation>
                <summary>Matches a gain code in a channel code</summary>
                <description>Matches a gain code in a channel code, such as H for high gain and L for low gain. See the
                        <a href="http://www.iris.edu/manuals/SEED_appA.htm">SEED manual</a> for the list of available
                    code letters.</description>
                <example>
                    <gainCode>H</gainCode>
                </example>
            </xsd:annotation>
            <ref name="singleLetterOrNumber"/>
        </element>
    </define>
    <define name="orientationCode">
        <element name="orientationCode">
            <xsd:annotation>
                <summary>Matches a orientation code in a channel code</summary>
                <description>Matches a orientation code in a channel code, such as Z for vertical and N for north. See
                    the <a href="http://www.iris.edu/manuals/SEED_appA.htm">SEED manual</a> for the list of available
                    code letters.</description>
                <example>
                    <orientationCode>Z</orientationCode>
                </example>
            </xsd:annotation>
            <ref name="singleLetterOrNumber"/>
        </element>
    </define>
    <define name="AND">
        <element name="channelAND">
            <xsd:annotation>
                <summary>Matches all enclosed channel subsetters</summary>
                <description>The output is the logical AND of the outputs of all included channel subsetters. This means
                    that it will evaluate to true only if all the enclosed channel subsetters evaluate to true. The
                    subsetters after the first false outputted are not evaluated.</description>
                <example>
                    <channelAND>
                        <channelEffectiveTimeOverlap>
                            <startTime>20020701T00:00:00.001Z</startTime>
                            <endTime>20021030T00:00:00.001Z</endTime>
                        </channelEffectiveTimeOverlap>
                        <sampling>
                            <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
                    </channelAND>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="channelLogical"/>
            </oneOrMore>
        </element>
    </define>
    <define name="OR">
        <element name="channelOR">
            <xsd:annotation>
                <summary>Matches at least one enclosed channel subsetter</summary>
                <description>The output is the logical OR of the outputs of all included Channeel subsetters. This means
                    that it will evaluate to true if at least one of the enclosed channel subsetters evaluates to true.
                    The subsetters after the first true outputted are not evaluated.</description>
                <example>
                    <channelOR>
                        <channelEffectiveTimeOverlap>
                            <startTime>20020701T00:00:00.001Z</startTime>
                            <endTime>20021030T00:00:00.001Z</endTime>
                        </channelEffectiveTimeOverlap>
                        <sampling>
                            <min>1</min>
                            <max>40</max>
                            <interval>
                                <unit>SECOND</unit>
                                <value>1</value>
                            </interval>
                        </sampling>
                    </channelOR>
                </example>
            </xsd:annotation>
            <oneOrMore>
                <ref name="channelLogical"/>
            </oneOrMore>
        </element>
    </define>
    <define name="NOT">
        <element name="channelNOT">
            <xsd:annotation>
                <summary>Matches the negated output of the enclosed channel subsetter</summary>
                <description>The output is the logical NOT of the output of the enclosed channel subsetter. This means
                    that it will evaluate to false if the enclosed channel subsetter evaluates to true, and vice versa.</description>
            </xsd:annotation>
            <ref name="channel"/>
        </element>
    </define>
    <define name="sampling">
        <element name="sampling">
            <xsd:annotation>
                <summary>Matches if the sampling rate of the channel is within the range</summary>
                <description>Matches if the sampling rate of the channel is within the range. Both the min and max are
                    optional, although at least one must be given to have any effect</description>
                <example>
                    <sampling>
                        <min>1</min>
                        <max>40</max>
                        <timeInterval>
                            <unit>SECOND</unit>
                            <value>1</value>
                        </timeInterval>
                    </sampling>
                </example>
            </xsd:annotation>
            <ref name="samplingRange"/>
        </element>
    </define>
    <define name="effectiveTimeOverlap">
        <element name="channelEffectiveTimeOverlap">
            <xsd:annotation>
                <summary>Matches if the channel effective time overlaps the given time range</summary>
                <description>Matches if the channel effective time overlaps the given time range. This is generally used
                    to avoid processing channels that did not yet exist, or were deactivated before a time range of interest.</description>
            </xsd:annotation>
            <ref name="timeRange"/>
        </element>
    </define>
    <define name="orientationRange">
        <element name="orientationRange">
            <xsd:annotation>
                <summary>Checks if a channel's orientation lies within a range</summary>
                <description>The match is true if the channel's orientation is within the offset of the given azimuth
                    and dip. The offset, as well as the azimuth and dip are given in degrees.</description>
            </xsd:annotation>
            <element name="azimuth">
                <data type="float">
                    <xsd:annotation>
                        <example>45</example>
                    </xsd:annotation>
                </data>
            </element>
            <element name="dip">
                <data type="float">
                    <xsd:annotation>
                        <example>0</example>
                    </xsd:annotation>
                </data>
            </element>
            <element name="maxOffset">
                <data type="float">
                    <xsd:annotation>
                        <example>20</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="orientationAzimuthRange">
        <element name="orientationAzimuthRange">
            <xsd:annotation>
                <summary>Matches the azimuth of a channel</summary>
                <description>The match is true if azimuth of the channel's orientation is within the given azimuth
                    range. The min and max are given in degrees.</description>
            </xsd:annotation>
            <element name="min">
                <data type="float">
                    <xsd:annotation>
                        <example>-10</example>
                    </xsd:annotation>
                </data>
            </element>
            <element name="max">
                <data type="float">
                    <xsd:annotation>
                        <example>10</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="orientationDipRange">
        <element name="orientationDipRange">
            <xsd:annotation>
                <summary>Matches the dip of a channel</summary>
                <description>The match is true if the dip of the channel's orientation is within the given dip range.
                    The min and max are given in degrees.</description>
            </xsd:annotation>
            <element name="min">
                <data type="float">
                    <xsd:annotation>
                        <example>-10</example>
                    </xsd:annotation>
                </data>
            </element>
            <element name="max">
                <data type="float">
                    <xsd:annotation>
                        <example>10</example>
                    </xsd:annotation>
                </data>
            </element>
        </element>
    </define>
    <define name="externalChannelSubsetter">
        <element name="externalChannelSubsetter">
            <xsd:annotation>
                <summary>Use a channel subsetter external to SOD</summary>
                <description>$externalChannelSubsetterInfo.getRelaxHTML('../../../')</description>
                <example>
                    <externalChannelSubsetter>
                        <classname>edu.somewhere.seis.sodExt.subsetter.channel.MyChannelSubsetter</classname>
                    </externalChannelSubsetter>
                </example>
            </xsd:annotation>
            <ref name="externalClass"/>
        </element>
    </define>
    <define name="hadDataLastWeek">
        <element name="hadDataLastWeek">
            <xsd:annotation>
                <summary>Checks if a data center has data for a channel for the past week</summary>
            </xsd:annotation>
            <externalRef href="../waveform/fixedDataCenter.rng"/>
        </element>
    </define>
    <define name="responseWriter">
        <element name="responseWriter">
            <xsd:annotation>
                <summary>Prints channel responses to file</summary>
            </xsd:annotation>
            <optional>
                <element name="workingDir">
                    <xsd:annotation>
                        <summary>The base directory for response file output</summary>
                        <description>The value generated by location is appened to the value in workingDir to make the
                            location to write response files. This defaults to 'responses/'.</description>
                    </xsd:annotation>
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="location">
                    <data type="string">
                        <xsd:annotation>
                            <summary>Configures which files to write responses in</summary>
                            <description>Each response is put in a separate file using this <a
                                    href="../../templates.html">Velocity template</a> to determine the file name. The
                                template contains <a href="../../templateTypes.html#channel">channel</a>
                                <a href="../../templateTypes.html#site">site</a>, <a
                                href="../../templateTypes.html#station">station</a> and <a
                                href="../../templateTypes.html#net">net</a> variables. If no location element is given,
                                it defaults to "${channel.codes}.${channel.getStart('yyyy_DDD_HH_mm_ss')}.resp.resp".
                                Since every response should be in a different file, the template should produce unique
                                values for all successful channels in the run.</description>
                            <example>$network.code-$station.code-${channel.code}.resp</example>
                        </xsd:annotation>
                    </data>
                </element>
            </optional>
        </element>
    </define>
    <define name="sacPoleZeroWriter">
        <element name="sacPoleZeroWriter">
            <xsd:annotation>
                <summary>Prints channel poles and zeros to file</summary>
            </xsd:annotation>
            <optional>
                <element name="workingDir">
                    <xsd:annotation>
                        <summary>The base directory for pole zero file output</summary>
                        <description>The value generated by location is appened to the value in workingDir to make the
                            location to write polezero files. This defaults to 'polezero/'.</description>
                    </xsd:annotation>
                    <data type="string"/>
                </element>
            </optional>
            <optional>
                <element name="location">
                    <data type="string">
                        <xsd:annotation>
                            <summary>Configures which files to write pole zeros in</summary>
                            <description>Each pole zero is put in a separate file using this <a
                                    href="../../templates.html">Velocity template</a> to determine the file name. The
                                template contains <a href="../../templateTypes.html#channel">channel</a>
                                <a href="../../templateTypes.html#site">site</a>, <a
                                href="../../templateTypes.html#station">station</a> and <a
                                href="../../templateTypes.html#net">net</a> variables. If no location element is given,
                                it defaults to "${channel.codes}.${channel.getStart('yyyy_DDD_HH_mm_ss')}.resp.sacpz".
                                Since every response should be in a different file, the template should produce unique
                                values for all successful channels in the run.</description>
                            <example>polezero/$network.code-$station.code-${channel.code}.sacpz</example>
                        </xsd:annotation>
                    </data>
                </element>
            </optional>
        </element>
    </define>
    <define name="printline">
        <element name="printlineChannelProcess">
            <xsd:annotation>
                <summary>Prints every successful channel to the console or to the specified file</summary>
                <description>Prints out each channel on a new line. The template and filename elements are both <a
                        href="../../templates.html">Velocity templates</a> containing <a href="../../templateTypes.html#channel">channel</a>
                    <a href="../../templateTypes.html#site">site</a>, <a
                    href="../../templateTypes.html#station">station</a> and <a
                    href="../../templateTypes.html#net">net</a> variables. If no template element is given, it defaults
                    to "Channel: $channel". If no filename is given, the output goes to standard out.</description>
            </xsd:annotation>
            <interleave>
                <optional>
                    <element name="template">
                        <text/>
                    </element>
                </optional>
                <optional>
                    <element name="filename">
                        <text/>
                    </element>
                </optional>
            </interleave>
        </element>
    </define>
    <define name="stationHas">
        <element name="stationHas">
            <xsd:annotation>
                <summary>Matches the current channel if the enclosed channel subsetters are satisfied by the channels in
                    the station</summary>
                <description>The output is true if at least one channel in the station matches each of the enclosed
                    channel subsetters. For example this could be used with a channelNOT to select SH? only if the
                    station does not have BH?.</description>
            </xsd:annotation>
            <oneOrMore>
                <ref name="channel"/>
            </oneOrMore>
        </element>
    </define>
    <define name="alwaysSuccess">
        <element name="alwaysSuccess">
            <xsd:annotation>
                <summary>Runs the enclosed subsetters in order until one fails, then passes the channel</summary>
                <description>Allows a failing channel subsetter to run while passing the channel onto the waveform arm.
                    This can be useful if you only want to run a particular processor if a channel meets a certain
                    criteria, but you want the waveform arm to process it regardless.</description>
            </xsd:annotation>
            <zeroOrMore>
                <ref name="channelLogical"/>
            </zeroOrMore>
        </element>
    </define>
    <define name="hasResponse">
        <element name="hasResponse">
            <xsd:annotation>
                <summary>Passes a channel if the network server has reponse information for it</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="hasSensitivity">
        <element name="hasSensitivity">
            <xsd:annotation>
                <summary>Passes a channel if the network server has sensitivity information for it</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="repairSensitivity">
        <element name="repairSensitivity">
            <xsd:annotation>
                <summary>Corrects sensitivity information for a channel from the response if the sensitivity is incorrect.</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="clockId">
        <element name="clockId">
            <xsd:annotation>
                <summary>Matches the clock id of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="integer"/>
        </element>
    </define>
    <define name="clockManufacturer">
        <element name="clockManufacturer">
            <xsd:annotation>
                <summary>Matches the clock manufacturer of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="clockModel">
        <element name="clockModel">
            <xsd:annotation>
                <summary>Matches the clock model of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="clockSerial">
        <element name="clockSerial">
            <xsd:annotation>
                <summary>Matches the clock's serial number of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="clockType">
        <element name="clockType">
            <xsd:annotation>
                <summary>Matches the clock type of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="dasId">
        <element name="dasId">
            <xsd:annotation>
                <summary>Matches the DAS id of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="integer"/>
        </element>
    </define>
    <define name="dasManufacturer">
        <element name="dasManufacturer">
            <xsd:annotation>
                <summary>Matches the DAS manufacturer of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="dasModel">
        <element name="dasModel">
            <xsd:annotation>
                <summary>Matches the DAS's model of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="dasSerial">
        <element name="dasSerial">
            <xsd:annotation>
                <summary>Matches the DAS's serial number of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="dasStyle">
        <element name="dasStyle">
            <xsd:annotation>
                <summary>Matches the DAS's recording style of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="integer"/>
        </element>
    </define>
    <define name="sensorId">
        <element name="sensorId">
            <xsd:annotation>
                <summary>Matches the sensor id of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="integer"/>
        </element>
    </define>
    <define name="sensorManufacturer">
        <element name="sensorManufacturer">
            <xsd:annotation>
                <summary>Matches the sensor manufacturer of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="sensorModel">
        <element name="sensorModel">
            <xsd:annotation>
                <summary>Matches the sensor's model of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="sensorSerial">
        <element name="sensorSerial">
            <xsd:annotation>
                <summary>Matches the sensor's serial number of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="string"/>
        </element>
    </define>
    <define name="sensorNominalHighFreq">
        <element name="sensorNominalHighFreq">
            <xsd:annotation>
                <summary>Matches the sensor's nominal high frequency of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="float"/>
        </element>
    </define>
    <define name="sensorNominalLowFreq">
        <element name="sensorNominalLowFreq">
            <xsd:annotation>
                <summary>Matches the sensor's nominal low frequency of the channel's instrumentation</summary>
            </xsd:annotation>
            <data type="float"/>
        </element>
    </define>
    <define name="isFlipped">
        <element name="isFlipped">
            <xsd:annotation>
                <summary>Passes channels whose orientation code are inverted with regards to their orientation.</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
    <define name="hasNegativeSensitivity">
        <element name="hasNegativeSensitivity">
            <xsd:annotation>
                <summary>Passes channels with a sensitivity less than 0</summary>
            </xsd:annotation>
            <empty/>
        </element>
    </define>
</grammar>
